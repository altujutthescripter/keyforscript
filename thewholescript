local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Universal Humanoid Editor | Umvtt",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Humanoid Editor | Processing data.",
   LoadingSubtitle = "by Umvtt",
   Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   ToggleUIKeybind = "J", -- The keybind to toggle the UI visibility (string like "K" or Enum.KeyCode)

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Humanoid Editor"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = true, -- Set this to true to use our key system
   KeySettings = {
      Title = "Key System",
      Subtitle = "Join our discord server to get the key.",
      Note = "The key is on discord.", -- Use this to tell the user how to get a key
      FileName = "KeyForEditor", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = false, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = true, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"https://raw.githubusercontent.com/altujutthescripter/keyforscript/refs/heads/main/keyfixed?token=GHSAT0AAAAAADIXIFUIW4YDHMJX4DPQ3BV42ETJEGA"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local EditorTab = Window:CreateTab("Editor", "file-check")

local WJSection = EditorTab:CreateSection("Editor")

local walkInput = EditorTab:CreateInput({
   Name = "WalkSpeed Modifier",
   CurrentValue = "16",
   PlaceholderText = "Default is: 16",
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(Text)
      -- Convert Text to a number, defaulting to 0 if invalid (or nil)
      local numberValue = tonumber(Text) or 0  -- If Text is not a valid number, it will be 0

      -- Now, numberValue is guaranteed to be a number, and you can use it
      game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = numberValue
   end,
})

local jumpInput = EditorTab:CreateInput({
   Name = "JumpPower Modifier",
   CurrentValue = "50",
   PlaceholderText = "Default is: 50",
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(Text)
      -- Convert Text to a number, defaulting to 0 if invalid (or nil)
      local numberValue = tonumber(Text) or 0  -- If Text is not a valid number, it will be 0

      -- Now, numberValue is guaranteed to be a number, and you can use it
      game.Players.LocalPlayer.Character.Humanoid.JumpPower = numberValue
   end,
})

local ExtraSection = EditorTab:CreateSection("Extras")

local ingjumpButton = EditorTab:CreateButton({
   Name = "Infinite Jump",
   Callback = function()    
        local InfiniteJumpEnabled = true
        game:GetService("UserInputService").JumpRequest:connect(function()
	        if InfiniteJumpEnabled then
		        game:GetService"Players".LocalPlayer.Character:FindFirstChildOfClass'Humanoid':ChangeState("Jumping")
	        end
        end)
   end,
})

local flyButton = EditorTab:CreateButton({
   Name = "Fly GUI",
   Callback = function()
        -- Gui to Lua
        -- Version: 3.2

        -- Instances:

        local main = Instance.new("ScreenGui")
        local Frame = Instance.new("Frame")
        local up = Instance.new("TextButton")
        local down = Instance.new("TextButton")
        local onof = Instance.new("TextButton")
        local TextLabel = Instance.new("TextLabel")
        local plus = Instance.new("TextButton")
        local speed = Instance.new("TextLabel")
        local mine = Instance.new("TextButton")

        --Properties:

        main.Name = "main"
        main.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
        main.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

        Frame.Parent = main
        Frame.BackgroundColor3 = Color3.fromRGB(163, 255, 137)
        Frame.BorderColor3 = Color3.fromRGB(103, 221, 213)
        Frame.Position = UDim2.new(0.100320168, 0, 0.379746825, 0)
        Frame.Size = UDim2.new(0, 190, 0, 57)

        up.Name = "up"
        up.Parent = Frame
        up.BackgroundColor3 = Color3.fromRGB(79, 255, 152)
        up.Size = UDim2.new(0, 44, 0, 28)
        up.Font = Enum.Font.SourceSans
        up.Text = "UP"
        up.TextColor3 = Color3.fromRGB(0, 0, 0)
        up.TextSize = 14.000

        down.Name = "down"
        down.Parent = Frame
        down.BackgroundColor3 = Color3.fromRGB(215, 255, 121)
        down.Position = UDim2.new(0, 0, 0.491228074, 0)
        down.Size = UDim2.new(0, 44, 0, 28)
        down.Font = Enum.Font.SourceSans
        down.Text = "DOWN"
        down.TextColor3 = Color3.fromRGB(0, 0, 0)
        down.TextSize = 14.000

        onof.Name = "onof"
        onof.Parent = Frame
        onof.BackgroundColor3 = Color3.fromRGB(255, 249, 74)
        onof.Position = UDim2.new(0.702823281, 0, 0.491228074, 0)
        onof.Size = UDim2.new(0, 56, 0, 28)
        onof.Font = Enum.Font.SourceSans
        onof.Text = "fly"
        onof.TextColor3 = Color3.fromRGB(0, 0, 0)
        onof.TextSize = 14.000

        TextLabel.Parent = Frame
        TextLabel.BackgroundColor3 = Color3.fromRGB(242, 60, 255)
        TextLabel.Position = UDim2.new(0.469327301, 0, 0, 0)
        TextLabel.Size = UDim2.new(0, 100, 0, 28)
        TextLabel.Font = Enum.Font.SourceSans
        TextLabel.Text = "Made By Umvtt"
        TextLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
        TextLabel.TextScaled = true
        TextLabel.TextSize = 14.000
        TextLabel.TextWrapped = true

        plus.Name = "plus"
        plus.Parent = Frame
        plus.BackgroundColor3 = Color3.fromRGB(133, 145, 255)
        plus.Position = UDim2.new(0.231578946, 0, 0, 0)
        plus.Size = UDim2.new(0, 45, 0, 28)
        plus.Font = Enum.Font.SourceSans
        plus.Text = "+"
        plus.TextColor3 = Color3.fromRGB(0, 0, 0)
        plus.TextScaled = true
        plus.TextSize = 14.000
        plus.TextWrapped = true

        speed.Name = "speed"
        speed.Parent = Frame
        speed.BackgroundColor3 = Color3.fromRGB(255, 85, 0)
        speed.Position = UDim2.new(0.468421042, 0, 0.491228074, 0)
        speed.Size = UDim2.new(0, 44, 0, 28)
        speed.Font = Enum.Font.SourceSans
        speed.Text = "1"
        speed.TextColor3 = Color3.fromRGB(0, 0, 0)
        speed.TextScaled = true
        speed.TextSize = 14.000
        speed.TextWrapped = true

        mine.Name = "mine"
        mine.Parent = Frame
        mine.BackgroundColor3 = Color3.fromRGB(123, 255, 247)
        mine.Position = UDim2.new(0.231578946, 0, 0.491228074, 0)
        mine.Size = UDim2.new(0, 45, 0, 29)
        mine.Font = Enum.Font.SourceSans
        mine.Text = "-"
        mine.TextColor3 = Color3.fromRGB(0, 0, 0)
        mine.TextScaled = true
        mine.TextSize = 14.000
        mine.TextWrapped = true

        speeds = 1

        local speaker = game:GetService("Players").LocalPlayer

        local chr = game.Players.LocalPlayer.Character
        local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")

        nowe = false

        game:GetService("StarterGui"):SetCore("SendNotification", { 
            Title = "Made by Umvtt";
            Text = "Have fun!";
            Icon = "rbxthumb://type=Asset&id=5107182114&w=150&h=150"})
        Duration = 16;

        Frame.Active = true -- main = gui
        Frame.Draggable = true

        onof.MouseButton1Down:connect(function()

            if nowe == true then
                nowe = false

                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing,true)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown,true)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying,true)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall,true)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp,true)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping,true)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Landed,true)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics,true)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding,true)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,true)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Running,true)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics,true)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated,true)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics,true)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming,true)
                speaker.Character.Humanoid:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)
            else 
                nowe = true



                for i = 1, speeds do
                    spawn(function()

                        local hb = game:GetService("RunService").Heartbeat


                        tpwalking = true
                        local chr = game.Players.LocalPlayer.Character
                        local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
                        while tpwalking and hb:Wait() and chr and hum and hum.Parent do
                            if hum.MoveDirection.Magnitude > 0 then
                                chr:TranslateBy(hum.MoveDirection)
                            end
                        end

                    end)
                end
                game.Players.LocalPlayer.Character.Animate.Disabled = true
                local Char = game.Players.LocalPlayer.Character
                local Hum = Char:FindFirstChildOfClass("Humanoid") or Char:FindFirstChildOfClass("AnimationController")

                for i,v in next, Hum:GetPlayingAnimationTracks() do
                    v:AdjustSpeed(0)
                end
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing,false)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown,false)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying,false)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall,false)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp,false)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping,false)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Landed,false)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics,false)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding,false)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Running,false)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics,false)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated,false)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics,false)
                speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming,false)
                speaker.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Swimming)
            end




            if game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid").RigType == Enum.HumanoidRigType.R6 then



                local plr = game.Players.LocalPlayer
                local torso = plr.Character.Torso
                local flying = true
                local deb = true
                local ctrl = {f = 0, b = 0, l = 0, r = 0}
                local lastctrl = {f = 0, b = 0, l = 0, r = 0}
                local maxspeed = 50
                local speed = 0


                local bg = Instance.new("BodyGyro", torso)
                bg.P = 9e4
                bg.maxTorque = Vector3.new(9e9, 9e9, 9e9)
                bg.cframe = torso.CFrame
                local bv = Instance.new("BodyVelocity", torso)
                bv.velocity = Vector3.new(0,0.1,0)
                bv.maxForce = Vector3.new(9e9, 9e9, 9e9)
                if nowe == true then
                    plr.Character.Humanoid.PlatformStand = true
                end
                while nowe == true or game:GetService("Players").LocalPlayer.Character.Humanoid.Health == 0 do
                    game:GetService("RunService").RenderStepped:Wait()

                    if ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0 then
                        speed = speed+.5+(speed/maxspeed)
                        if speed > maxspeed then
                            speed = maxspeed
                        end
                    elseif not (ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0) and speed ~= 0 then
                        speed = speed-1
                        if speed < 0 then
                            speed = 0
                        end
                    end
                    if (ctrl.l + ctrl.r) ~= 0 or (ctrl.f + ctrl.b) ~= 0 then
                        bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (ctrl.f+ctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(ctrl.l+ctrl.r,(ctrl.f+ctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
                        lastctrl = {f = ctrl.f, b = ctrl.b, l = ctrl.l, r = ctrl.r}
                    elseif (ctrl.l + ctrl.r) == 0 and (ctrl.f + ctrl.b) == 0 and speed ~= 0 then
                        bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (lastctrl.f+lastctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(lastctrl.l+lastctrl.r,(lastctrl.f+lastctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
                    else
                        bv.velocity = Vector3.new(0,0,0)
                    end
                    --  game.Players.LocalPlayer.Character.Animate.Disabled = true
                    bg.cframe = game.Workspace.CurrentCamera.CoordinateFrame * CFrame.Angles(-math.rad((ctrl.f+ctrl.b)*50*speed/maxspeed),0,0)
                end
                ctrl = {f = 0, b = 0, l = 0, r = 0}
                lastctrl = {f = 0, b = 0, l = 0, r = 0}
                speed = 0
                bg:Destroy()
                bv:Destroy()
                plr.Character.Humanoid.PlatformStand = false
                game.Players.LocalPlayer.Character.Animate.Disabled = false
                tpwalking = false




            else
                local plr = game.Players.LocalPlayer
                local UpperTorso = plr.Character.UpperTorso
                local flying = true
                local deb = true
                local ctrl = {f = 0, b = 0, l = 0, r = 0}
                local lastctrl = {f = 0, b = 0, l = 0, r = 0}
                local maxspeed = 50
                local speed = 0


                local bg = Instance.new("BodyGyro", UpperTorso)
                bg.P = 9e4
                bg.maxTorque = Vector3.new(9e9, 9e9, 9e9)
                bg.cframe = UpperTorso.CFrame
                local bv = Instance.new("BodyVelocity", UpperTorso)
                bv.velocity = Vector3.new(0,0.1,0)
                bv.maxForce = Vector3.new(9e9, 9e9, 9e9)
                if nowe == true then
                    plr.Character.Humanoid.PlatformStand = true
                end
                while nowe == true or game:GetService("Players").LocalPlayer.Character.Humanoid.Health == 0 do
                    wait()

                    if ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0 then
                        speed = speed+.5+(speed/maxspeed)
                        if speed > maxspeed then
                            speed = maxspeed
                        end
                    elseif not (ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0) and speed ~= 0 then
                        speed = speed-1
                        if speed < 0 then
                            speed = 0
                        end
                    end
                    if (ctrl.l + ctrl.r) ~= 0 or (ctrl.f + ctrl.b) ~= 0 then
                        bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (ctrl.f+ctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(ctrl.l+ctrl.r,(ctrl.f+ctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
                        lastctrl = {f = ctrl.f, b = ctrl.b, l = ctrl.l, r = ctrl.r}
                    elseif (ctrl.l + ctrl.r) == 0 and (ctrl.f + ctrl.b) == 0 and speed ~= 0 then
                        bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (lastctrl.f+lastctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(lastctrl.l+lastctrl.r,(lastctrl.f+lastctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
                    else
                        bv.velocity = Vector3.new(0,0,0)
                    end

                    bg.cframe = game.Workspace.CurrentCamera.CoordinateFrame * CFrame.Angles(-math.rad((ctrl.f+ctrl.b)*50*speed/maxspeed),0,0)
                end
                ctrl = {f = 0, b = 0, l = 0, r = 0}
                lastctrl = {f = 0, b = 0, l = 0, r = 0}
                speed = 0
                bg:Destroy()
                bv:Destroy()
                plr.Character.Humanoid.PlatformStand = false
                game.Players.LocalPlayer.Character.Animate.Disabled = false
                tpwalking = false



            end





        end)


        up.MouseButton1Down:connect(function()
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0,2,0)

        end)


        down.MouseButton1Down:connect(function()

            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0,-2,0)

        end)


        game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(char)
            wait(0.7)
            game.Players.LocalPlayer.Character.Humanoid.PlatformStand = false
            game.Players.LocalPlayer.Character.Animate.Disabled = false

        end)


        plus.MouseButton1Down:connect(function()
            speeds = speeds + 1
            speed.Text = speeds
            if nowe == true then


            tpwalking = false
            for i = 1, speeds do
                spawn(function()

                    local hb = game:GetService("RunService").Heartbeat


                    tpwalking = true
                    local chr = game.Players.LocalPlayer.Character
                    local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
                    while tpwalking and hb:Wait() and chr and hum and hum.Parent do
                        if hum.MoveDirection.Magnitude > 0 then
                            chr:TranslateBy(hum.MoveDirection)
                        end
                    end

                end)
                end
                end
        end)
        mine.MouseButton1Down:connect(function()
            if speeds == 1 then
                speed.Text = 'can not be less than 1'
                wait(1)
                speed.Text = speeds
            else
            speeds = speeds - 1
                speed.Text = speeds
                if nowe == true then
            tpwalking = false
            for i = 1, speeds do
                spawn(function()

                    local hb = game:GetService("RunService").Heartbeat


                    tpwalking = true
                    local chr = game.Players.LocalPlayer.Character
                    local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
                    while tpwalking and hb:Wait() and chr and hum and hum.Parent do
                        if hum.MoveDirection.Magnitude > 0 then
                            chr:TranslateBy(hum.MoveDirection)
                        end
                    end

                end)
                end
                end
                end
        end)
   end,
})

local BlatantTab = Window:CreateTab("Blatant", "swords") -- Title, Image

local BlatantSection = BlatantTab:CreateSection("Blatant")

local aimbotButton = BlatantTab:CreateButton({
   Name = "Aimbot",
   Callback = function()
        local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

        local HttpService = game:GetService("HttpService")
        local RunService = game:GetService("RunService")
        local TeleportService = game:GetService("TeleportService")
        local players = game:GetService("Players")
        local wrk = game:GetService("Workspace")
        local plr = players.LocalPlayer
        local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
        local humanoid = plr.Character:FindFirstChild("Humanoid")

        local function onCharacterAdded(character)
            hrp = character:WaitForChild("HumanoidRootPart")
            humanoid = character:WaitForChild("Humanoid")
        end

        plr.CharacterAdded:Connect(onCharacterAdded)

        if plr.Character then
            onCharacterAdded(plr.Character)
        end

        local camera = wrk.CurrentCamera
        local mouse = plr:GetMouse()

        local httprequest = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request

        local hue = 0
        local rainbowFov = false
        local rainbowSpeed = 0.005

        local aimFov = 100
        local aimParts = {"Head"}
        local aiming = false
        local predictionStrength = 0.065
        local smoothing = 0.05

        local aimbotEnabled = false
        local wallCheck = true
        local stickyAimEnabled = false
        local teamCheck = false
        local healthCheck = false
        local minHealth = 0

        local antiAim = false

        local antiAimAmountX = 0
        local antiAimAmountY = -100
        local antiAimAmountZ = 0

        local antiAimMethod = "Reset Velo"

        local randomVeloRange = 100

        local spinBot = false
        local spinBotSpeed = 20

        local circleColor = Color3.fromRGB(255, 0, 0)
        local targetedCircleColor = Color3.fromRGB(0, 255, 0)

        local aimViewerEnabled = false
        local ignoreSelf = true

        local Window = Rayfield:CreateWindow({
            Name = "‚ñ∂ Universal Hub ‚óÄ",
            LoadingTitle = "Loading...",
            LoadingSubtitle = "by Umvtt ü•µ",
            ConfigurationSaving = {
                Enabled = true,
                FolderName = "UniversalHub",
                FileName = "byUmvtt"
            },
        })

        local Aimbot = Window:CreateTab("Aimbot üéØ")
        local AntiAim = Window:CreateTab("Anti-Aim üò°")
        local Misc = Window:CreateTab("Misc ü§∑‚Äç‚ôÇÔ∏è")

        local fovCircle = Drawing.new("Circle")
        fovCircle.Thickness = 2
        fovCircle.Radius = aimFov
        fovCircle.Filled = false
        fovCircle.Color = circleColor
        fovCircle.Visible = false

        local currentTarget = nil

        local function checkTeam(player)
            if teamCheck and player.Team == plr.Team then
                return true
            end
            return false
        end

        local function checkWall(targetCharacter)
            local targetHead = targetCharacter:FindFirstChild("Head")
            if not targetHead then return true end

            local origin = camera.CFrame.Position
            local direction = (targetHead.Position - origin).unit * (targetHead.Position - origin).magnitude
            local raycastParams = RaycastParams.new()
            raycastParams.FilterDescendantsInstances = {plr.Character, targetCharacter}
            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

            local raycastResult = wrk:Raycast(origin, direction, raycastParams)
            return raycastResult and raycastResult.Instance ~= nil
        end

        local function getClosestPart(character)
            local closestPart = nil
            local shortestCursorDistance = aimFov
            local cameraPos = camera.CFrame.Position

            for _, partName in ipairs(aimParts) do
                local part = character:FindFirstChild(partName)
                if part then
                    local partPos = camera:WorldToViewportPoint(part.Position)
                    local screenPos = Vector2.new(partPos.X, partPos.Y)
                    local cursorDistance = (screenPos - Vector2.new(mouse.X, mouse.Y)).Magnitude

                    if cursorDistance < shortestCursorDistance and partPos.Z > 0 then
                        shortestCursorDistance = cursorDistance
                        closestPart = part
                    end
                end
            end

            return closestPart
        end

        local function getTarget()
            local nearestPlayer = nil
            local closestPart = nil
            local shortestCursorDistance = aimFov

            for _, player in ipairs(players:GetPlayers()) do
                if player ~= plr and player.Character and not checkTeam(player) then
                    if player.Character.Humanoid.Health >= minHealth or not healthCheck then
                        local targetPart = getClosestPart(player.Character)
                        if targetPart then
                            local screenPos = camera:WorldToViewportPoint(targetPart.Position)
                            local cursorDistance = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude

                            if cursorDistance < shortestCursorDistance then
                                if not wallCheck or not checkWall(player.Character) then
                                    shortestCursorDistance = cursorDistance
                                    nearestPlayer = player
                                    closestPart = targetPart
                                end
                            end
                        end
                    end
                end
            end

            return nearestPlayer, closestPart
        end

        local function predict(player, part)
            if player and part then
                local velocity = player.Character.HumanoidRootPart.Velocity
                local predictedPosition = part.Position + (velocity * predictionStrength)
                return predictedPosition
            end
            return nil
        end

        local function smooth(from, to)
            return from:Lerp(to, smoothing)
        end

        local function aimAt(player, part)
            local predictedPosition = predict(player, part)
            if predictedPosition then
                if player.Character.Humanoid.Health >= minHealth or not healthCheck then
                    local targetCFrame = CFrame.new(camera.CFrame.Position, predictedPosition)
                    camera.CFrame = smooth(camera.CFrame, targetCFrame)
                end
            end
        end

        RunService.RenderStepped:Connect(function()
            if aimbotEnabled then
                local offset = 50
                fovCircle.Position = Vector2.new(mouse.X, mouse.Y + offset)

                if rainbowFov then
                    hue = hue + rainbowSpeed
                    if hue > 1 then hue = 0 end
                    fovCircle.Color = Color3.fromHSV(hue, 1, 1)
                else
                    if aiming and currentTarget then
                        fovCircle.Color = targetedCircleColor
                    else
                        fovCircle.Color = circleColor
                    end
                end

                if aiming then
                    if stickyAimEnabled and currentTarget then
                        local headPos = camera:WorldToViewportPoint(currentTarget.Character.Head.Position)
                        local screenPos = Vector2.new(headPos.X, headPos.Y)
                        local cursorDistance = (screenPos - Vector2.new(mouse.X, mouse.Y)).Magnitude

                        if cursorDistance > aimFov or (wallCheck and checkWall(currentTarget.Character)) or checkTeam(currentTarget) then
                            currentTarget = nil
                        end
                    end

                    if not stickyAimEnabled or not currentTarget then
                        local target, targetPart = getTarget()
                        currentTarget = target
                        currentTargetPart = targetPart
                    end

                    if currentTarget and currentTargetPart then
                        aimAt(currentTarget, currentTargetPart)
                    end
                else
                    currentTarget = nil
                end
            end
        end)

        RunService.Heartbeat:Connect(function()
            if antiAim then
                if antiAimMethod == "Reset Velo" then
                    local vel = hrp.Velocity
                    hrp.Velocity = Vector3.new(antiAimAmountX, antiAimAmountY, antiAimAmountZ)
                    RunService.RenderStepped:Wait()
                    hrp.Velocity = vel
                elseif antiAimMethod == "Reset Pos [BROKEN]" then
                    local pos = hrp.CFrame
                    hrp.Velocity = Vector3.new(antiAimAmountX, antiAimAmountY, antiAimAmountZ)
                    RunService.RenderStepped:Wait()
                    hrp.CFrame = pos
                elseif antiAimMethod == "Random Velo" then
                    local vel = hrp.Velocity
                    local a = math.random(-randomVeloRange,randomVeloRange)
                    local s = math.random(-randomVeloRange,randomVeloRange)
                    local d = math.random(-randomVeloRange,randomVeloRange)
                    hrp.Velocity = Vector3.new(a,s,d)
                    RunService.RenderStepped:Wait()
                    hrp.Velocity = vel
                end
            end
        end)

        mouse.Button2Down:Connect(function()
            if aimbotEnabled then
                aiming = true
            end
        end)

        mouse.Button2Up:Connect(function()
            if aimbotEnabled then
                aiming = false
            end
        end)

        local aimbot = Aimbot:CreateToggle({
            Name = "Aimbot",
            CurrentValue = false,
            Flag = "Aimbot",
            Callback = function(Value)
                aimbotEnabled = Value
                fovCircle.Visible = Value
            end
        })

        local aimpart = Aimbot:CreateDropdown({
            Name = "Aim Part",
            Options = {"Head","HumanoidRootPart","Left Arm","Right Arm","Torso","Left Leg","Right Leg"},
            CurrentOption = {"Head"},
            MultipleOptions = true,
            Flag = "AimPart",
            Callback = function(Options)
                aimParts = Options
            end,
        })

        local smoothingslider = Aimbot:CreateSlider({
            Name = "Smoothing",
            Range = {0, 100},
            Increment = 1,
            CurrentValue = 5,
            Flag = "Smoothing",
            Callback = function(Value)
                smoothing = 1 - (Value / 100)
            end,
        })

        local predictionstrength = Aimbot:CreateSlider({
            Name = "Prediction Strength",
            Range = {0, 0.2},
            Increment = 0.001,
            CurrentValue = 0.065,
            Flag = "PredictionStrength",
            Callback = function(Value)
                predictionStrength = Value
            end,
        })

        local fovvisibility = Aimbot:CreateToggle({
            Name = "Fov Visibility",
            CurrentValue = true,
            Flag = "FovVisibility",
            Callback = function(Value)
                fovCircle.Visible = Value
            end
        })

        local aimbotfov = Aimbot:CreateSlider({
            Name = "Aimbot Fov",
            Range = {0, 1000},
            Increment = 1,
            CurrentValue = 100,
            Flag = "AimbotFov",
            Callback = function(Value)
                aimFov = Value
                fovCircle.Radius = aimFov
            end,
        })

        local wallcheck = Aimbot:CreateToggle({
            Name = "Wall Check",
            CurrentValue = true,
            Flag = "WallCheck",
            Callback = function(Value)
                wallCheck = Value
            end
        })

        local stickyaim = Aimbot:CreateToggle({
            Name = "Sticky Aim",
            CurrentValue = false,
            Flag = "StickyAim",
            Callback = function(Value)
                stickyAimEnabled = Value
            end
        })

        local teamchecktoggle = Aimbot:CreateToggle({
            Name = "Team Check",
            CurrentValue = false,
            Flag = "TeamCheck",
            Callback = function(Value)
                teamCheck = Value
            end
        })

        local healthchecktoggle = Aimbot:CreateToggle({
            Name = "Health Check",
            CurrentValue = false,
            Flag = "HealthCheck",
            Callback = function(Value)
                healthCheck = Value
            end
        })

        local minhealth = Aimbot:CreateSlider({
            Name = "Min Health",
            Range = {0, 100},
            Increment = 1,
            CurrentValue = 0,
            Flag = "MinHealth",
            Callback = function(Value)
                minHealth = Value
            end,
        })

        local circlecolor = Aimbot:CreateColorPicker({
            Name = "Fov Color",
            Color = circleColor,
            Callback = function(Color)
                circleColor = Color
                fovCircle.Color = Color
            end
        })

        local targetedcirclecolor = Aimbot:CreateColorPicker({
            Name = "Targeted Fov Color",
            Color = targetedCircleColor,
            Callback = function(Color)
                targetedCircleColor = Color
            end
        })

        local circlerainbow = Aimbot:CreateToggle({
            Name = "Rainbow Fov",
            CurrentValue = false,
            Flag = "RainbowFov",
            Callback = function(Value)
                rainbowFov = Value
            end
        })

        local antiaimtoggle = AntiAim:CreateToggle({
            Name = "Anti-Aim",
            CurrentValue = false,
            Flag = "AntiAim",
            Callback = function(Value)
                antiAim = Value
                if Value then
                    Rayfield:Notify({Title = "Anti-Aim", Content = "Enabled!", Duration = 1, Image = 4483362458,})
                else
                    Rayfield:Notify({Title = "Anti-Aim", Content = "Disabled!", Duration = 1, Image = 4483362458,})
                end
            end
        })

        local antiaimmethod = AntiAim:CreateDropdown({
            Name = "Anti-Aim Method",
            Options = {"Reset Velo","Random Velo","Reset Pos [BROKEN]"},
            CurrentOption = "Reset Velo",
            Flag = "AntiAimMethod",
            Callback = function(Option)
                antiAimMethod = type(Option) == "table" and Option[1] or Option
                if antiAimMethod == "Reset Velo" then
                    Rayfield:Notify({Title = "Reset Velocity", Content = "Nobody will see it, but exploiters will aim in the wrong place.", Duration = 5, Image = 4483362458,})
                elseif antiAimMethod == "Reset Pos [BROKEN]" then
                    Rayfield:Notify({Title = "Reset Pos [BROKEN]", Content = "This is a bit buggy right now, so idk if it works that well", Duration = 5, Image = 4483362458,})
                elseif antiAimMethod == "Random Velo" then
                    Rayfield:Notify({Title = "Random Velocity", Content = "Depending on ping some peoplev will see u 'teleporting' around but you are actually in the same spot the entire time.", Duration = 5, Image = 4483362458,})
                end
            end,
        })

        local antiaimamountx = AntiAim:CreateSlider({
            Name = "Anti-Aim Amount X",
            Range = {-1000, 1000},
            Increment = 10,
            CurrentValue = 0,
            Flag = "AntiAimAmountX",
            Callback = function(Value)
                antiAimAmountX = Value
            end,
        })

        local antiaimamounty = AntiAim:CreateSlider({
            Name = "Anti-Aim Amount Y",
            Range = {-1000, 1000},
            Increment = 10,
            CurrentValue = -100,
            Flag = "AntiAimAmountY",
            Callback = function(Value)
                antiAimAmountY = Value
            end,
        })

        local antiaimamountz = AntiAim:CreateSlider({
            Name = "Anti-Aim Amount Z",
            Range = {-1000, 1000},
            Increment = 10,
            CurrentValue = 0,
            Flag = "AntiAimAmountZ",
            Callback = function(Value)
                antiAimAmountZ = Value
            end,
        })

        local randomvelorange = AntiAim:CreateSlider({
            Name = "Random Velo Range",
            Range = {0, 1000},
            Increment = 10,
            CurrentValue = 100,
            Flag = "RandomVeloRange",
            Callback = function(Value)
                randomVeloRange = Value
            end,
        })

        -- [< Misc >]

        local spinbottoggle = Misc:CreateToggle({
            Name = "Spin-Bot",
            CurrentValue = false,
            Flag = "SpinBot",
            Callback = function(Value)
                spinBot = Value
                if Value then
                    for i,v in pairs(hrp:GetChildren()) do
                        if v.Name == "Spinning" then
                            v:Destroy()
                        end
                    end
                    plr.Character.Humanoid.AutoRotate = false
                    local Spin = Instance.new("BodyAngularVelocity")
                    Spin.Name = "Spinning"
                    Spin.Parent = hrp
                    Spin.MaxTorque = Vector3.new(0, math.huge, 0)
                    Spin.AngularVelocity = Vector3.new(0,spinBotSpeed,0)
                    Rayfield:Notify({Title = "Spin Bot", Content = "Enabled!", Duration = 1, Image = 4483362458,})
                else
                    for i,v in pairs(hrp:GetChildren()) do
                        if v.Name == "Spinning" then
                            v:Destroy()
                        end
                    end
                    plr.Character.Humanoid.AutoRotate = true
                    Rayfield:Notify({Title = "Spin Bot", Content = "Disabled!", Duration = 1, Image = 4483362458,})
                end
            end
        })

        local spinbotspeed = Misc:CreateSlider({
            Name = "Spin-Bot Speed",
            Range = {0, 1000},
            Increment = 1,
            CurrentValue = 20,
            Flag = "SpinBotSpeed",
            Callback = function(Value)
                spinBotSpeed = Value
                if spinBot then
                    for i,v in pairs(hrp:GetChildren()) do
                        if v.Name == "Spinning" then
                            v:Destroy()
                        end
                    end
                    local Spin = Instance.new("BodyAngularVelocity")
                    Spin.Name = "Spinning"
                    Spin.Parent = hrp
                    Spin.MaxTorque = Vector3.new(0, math.huge, 0)
                    Spin.AngularVelocity = Vector3.new(0,Value,0)
                end
            end,
        })

        local ServerHop = Misc:CreateButton({
            Name = "Server Hop",
            Callback = function()
                if httprequest then
                    local servers = {}
                    local req = httprequest({Url = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100&excludeFullGames=true", game.PlaceId)})
                    local body = HttpService:JSONDecode(req.Body)
                
                    if body and body.data then
                        for i, v in next, body.data do
                            if type(v) == "table" and tonumber(v.playing) and tonumber(v.maxPlayers) and v.playing < v.maxPlayers and v.id ~= game.JobId then
                                table.insert(servers, 1, v.id)
                            end
                        end
                    end
                
                    if #servers > 0 then
                        TeleportService:TeleportToPlaceInstance(game.PlaceId, servers[math.random(1, #servers)], plr)
                    else
                        Rayfield:Notify({Title = "Server Hop", Content = "Couldn't find a valid server!!!", Duration = 1, Image = 4483362458,})
                    end
                else
                    Rayfield:Notify({Title = "Server Hop", Content = "Your executor is ass and cant handle a fucking server hop you little timmy", Duration = 1, Image = 4483362458,})
                end
            end,
        })
   end,
})

local ESPButton = BlatantTab:CreateButton({
   Name = "ESP",
   Callback = function()
        assert(Drawing, 'exploit not supported')

        if not syn and not PROTOSMASHER_LOADED then print'Uh eh script' end

        if not cloneref then cloneref = function(o) return o end end

        local UserInputService = cloneref(game:GetService'UserInputService')
        local HttpService = cloneref(game:GetService'HttpService')
        local TweenService = cloneref(game:GetService'TweenService')
        local RunService = cloneref(game:GetService'RunService')
        local Players = game:GetService'Players'
        local LocalPlayer = Players.LocalPlayer
        local Camera = workspace.CurrentCamera
        local Mouse = LocalPlayer:GetMouse()
        local V2New = Vector2.new
        local V3New = Vector3.new
        local WTVP = Camera.WorldToViewportPoint
        local WorldToViewport = function(...) return WTVP(Camera, ...) end
        local Menu = {}
        local MouseHeld = false
        local LastRefresh = 0
        local OptionsFile = 'IC3_ESP_SETTINGS.dat'
        local Binding = false
        local BindedKey = nil
        local OIndex = 0
        local LineBox = {}
        local UIButtons = {}
        local Sliders = {}
        local ColorPicker = { Loading = false, LastGenerated = 0 }
        local Dragging = false
        local DraggingUI = false
        local Rainbow = false
        local DragOffset = V2New()
        local DraggingWhat = nil
        local OldData = {}
        local IgnoreList = {}
        local EnemyColor = Color3.new(1, 0, 0)
        local TeamColor = Color3.new(0, 1, 0)
        local MenuLoaded = false
        local ErrorLogging = false
        local TracerPosition = V2New(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y - 135)
        local DragTracerPosition = false
        local SubMenu = {}
        local IsSynapse = syn and not PROTOSMASHER_LOADED
        local Connections = { Active = {} }
        local Signal = {} Signal.__index = Signal
        local GetCharacter, CurrentColorPicker, Spectating

        local QUAD_SUPPORTED_EXPLOIT = pcall(function() Drawing.new('Quad'):Remove() end)

        shared.MenuDrawingData = shared.MenuDrawingData or { Instances = {} }
        shared.InstanceData = shared.InstanceData or {}
        shared.RSName = shared.RSName or ('UnnamedESP_by_ic3-' .. HttpService:GenerateGUID(false))

        local GetDataName = shared.RSName .. '-GetData'
        local UpdateName = shared.RSName .. '-Update'

        local Debounce = setmetatable({}, {
            __index = function(t, i)
                return rawget(t, i) or false
            end
        })

        if shared.UESP_InputChangedCon then shared.UESP_InputChangedCon:Disconnect() end
        if shared.UESP_InputBeganCon then shared.UESP_InputBeganCon:Disconnect() end
        if shared.UESP_InputEndedCon then shared.UESP_InputEndedCon:Disconnect() end
        if shared.CurrentColorPicker then shared.CurrentColorPicker:Dispose() end

        local function IsStringEmpty(String)
            if type(String) == 'string' then
                return String:match'^%s+$' ~= nil or #String == 0 or String == '' or false;
            end
            
            return false;
        end

        local function Set(t, i, v) t[i] = v end

        local Teams = {};
        local CustomTeams = { -- Games that don't use roblox's team system
            [2563455047] = {
                Initialize = function()
                    Teams.Sheriffs = {}; -- prevent big error
                    Teams.Bandits = {}; -- prevent big error
                    local Func = game:GetService'ReplicatedStorage':WaitForChild('RogueFunc', 1);
                    local Event = game:GetService'ReplicatedStorage':WaitForChild('RogueEvent', 1);
                    local S, B = Func:InvokeServer'AllTeamData';

                    Teams.Sheriffs = S;
                    Teams.Bandits = B;

                    Event.OnClientEvent:Connect(function(id, PlayerName, Team, Remove) -- stolen straight from decompiled src lul
                        if id == 'UpdateTeam' then
                            local TeamTable, NotTeamTable
                            if Team == 'Bandits' then
                                TeamTable = TDM.Bandits
                                NotTeamTable = TDM.Sheriffs
                            else
                                TeamTable = TDM.Sheriffs
                                NotTeamTable = TDM.Bandits
                            end
                            if Remove then
                                TeamTable[PlayerName] = nil
                            else
                                TeamTable[PlayerName] = true
                                NotTeamTable[PlayerName] = nil
                            end
                            if PlayerName == LocalPlayer.Name then
                                TDM.Friendlys = TeamTable
                                TDM.Enemies = NotTeamTable
                            end
                        end
                    end)
                end;
                CheckTeam = function(Player)
                    local LocalTeam = Teams.Sheriffs[LocalPlayer.Name] and Teams.Sheriffs or Teams.Bandits;
                    
                    return LocalTeam[Player.Name] and true or false;
                end;
            };
            [5208655184] = {
                CheckTeam = function(Player)
                    local LocalLastName = LocalPlayer:GetAttribute'LastName' if not LocalLastName or IsStringEmpty(LocalLastName) then return true end
                    local PlayerLastName = Player:GetAttribute'LastName' if not PlayerLastName then return false end

                    return PlayerLastName == LocalLastName
                end
            };
            [3541987450] = {
                CheckTeam = function(Player)
                    local LocalStats = LocalPlayer:FindFirstChild'leaderstats';
                    local LocalLastName = LocalStats and LocalStats:FindFirstChild'LastName'; if not LocalLastName or IsStringEmpty(LocalLastName.Value) then return true; end
                    local PlayerStats = Player:FindFirstChild'leaderstats';
                    local PlayerLastName = PlayerStats and PlayerStats:FindFirstChild'LastName'; if not PlayerLastName then return false; end

                    return PlayerLastName.Value == LocalLastName.Value;
                end;
            };
            [6032399813] = {
                CheckTeam = function(Player)
                    local LocalStats = LocalPlayer:FindFirstChild'leaderstats';
                    local LocalGuildName = LocalStats and LocalStats:FindFirstChild'Guild'; if not LocalGuildName or IsStringEmpty(LocalGuildName.Value) then return true; end
                    local PlayerStats = Player:FindFirstChild'leaderstats';
                    local PlayerGuildName = PlayerStats and PlayerStats:FindFirstChild'Guild'; if not PlayerGuildName then return false; end

                    return PlayerGuildName.Value == LocalGuildName.Value;
                end;
            };
            [5735553160] = {
                CheckTeam = function(Player)
                    local LocalStats = LocalPlayer:FindFirstChild'leaderstats';
                    local LocalGuildName = LocalStats and LocalStats:FindFirstChild'Guild'; if not LocalGuildName or IsStringEmpty(LocalGuildName.Value) then return true; end
                    local PlayerStats = Player:FindFirstChild'leaderstats';
                    local PlayerGuildName = PlayerStats and PlayerStats:FindFirstChild'Guild'; if not PlayerGuildName then return false; end

                    return PlayerGuildName.Value == LocalGuildName.Value;
                end;
            };
        };

        local RenderList = {Instances = {}};

        function RenderList:AddOrUpdateInstance(Instance, Obj2Draw, Text, Color)
            RenderList.Instances[Instance] = { ParentInstance = Instance; Instance = Obj2Draw; Text = Text; Color = Color };
            return RenderList.Instances[Instance];
        end

        local CustomPlayerTag;
        local CustomESP;
        local CustomCharacter;
        local GetHealth;
        local GetAliveState;
        local CustomRootPartName;

        local Modules = {
            [292439477] = {
                Initialize = function()
                    if not create_comm_channel or not get_comm_channel then return end

                    local run_on_actor = runonactor or run_on_actor
                    local EventID, Event = create_comm_channel()
                    Event.Event:Connect(function(List)
                        PF_CharList = List
                    end)
                    
                    for Index, Actor in pairs(getactors()) do
                        run_on_actor(Actor, [[
                            local Event = get_comm_channel(...)

                            if not getrenv().shared.require then return end
                            
                            local RunService = game:GetService'RunService'
                            local Cache = debug.getupvalues(getrenv().shared.require)[1]._cache if not Cache then return end
                            local ReplicationInterface = rawget(rawget(Cache, 'ReplicationInterface'), 'module') if not ReplicationInterface then return end
                            local getEntry = rawget(ReplicationInterface, 'getEntry')

                            if shared.UNPFHB then shared.UNPFHB:Disconnect() end

                            shared.UNPFHB = RunService.Heartbeat:Connect(function()
                                local CharacterList = {}
                                
                                for Player, Entry in pairs(debug.getupvalues(getEntry)[1]) do
                                    local TPO = rawget(Entry, '_thirdPersonObject') if not TPO then continue end
                                    local Character = rawget(TPO, '_characterHash') if not Character then continue end
                                    local Torso = rawget(Character, 'Torso') if not Torso then continue end
                                    local HealthState = rawget(Entry, '_healthstate')

                                    CharacterList[Player.Name] = {
                                        Head = Character.Head,
                                        Torso = Character.Torso,
                                        Health = HealthState and rawget(HealthState, 'health0') or 100,
                                        Alive = rawget(Entry, '_alive')
                                    }
                                end

                                Event:Fire(CharacterList)
                            end)
                        ]], EventID)
                    end
                end,

                CustomCharacter = function(Player)
                    if not shared.PF_CharMT then
                        shared.PF_CharMT = {}
                        shared.PF_CharMT.__index = shared.PF_CharMT

                        function shared.PF_CharMT:FindFirstChild(Name)
                            return rawget(self, Name)
                        end

                        function shared.PF_CharMT:FindFirstChildOfClass() end
                    end

                    if PF_CharList and PF_CharList[Player.Name] then
                        local Character = PF_CharList[Player.Name]
                        
                        setmetatable(Character, shared.PF_CharMT)
                        
                        return Character
                    end
                end,

                GetHealth = function(Player)
                    if PF_CharList and PF_CharList[Player.Name] then
                        return PF_CharList[Player.Name].Health
                    end
                end,

                GetAliveState = function(Player)
                    if PF_CharList and PF_CharList[Player.Name] then
                        return PF_CharList[Player.Name].Alive
                    end
                end,

                CustomRootPartName = 'Torso',
            };
            [2950983942] = {
                CustomCharacter = function(Player)
                    if workspace:FindFirstChild'Players' then
                        return workspace.Players:FindFirstChild(Player.Name);
                    end
                end
            };
            [2262441883] = {
                CustomPlayerTag = function(Player)
                    return Player:FindFirstChild'Job' and (' [' .. Player.Job.Value .. ']') or '';
                end;
                CustomESP = function()
                    if workspace:FindFirstChild'MoneyPrinters' then
                        for i, v in pairs(workspace.MoneyPrinters:GetChildren()) do
                            local Main	= v:FindFirstChild'Main';
                            local Owner	= v:FindFirstChild'TrueOwner';
                            local Money	= v:FindFirstChild'Int' and v.Int:FindFirstChild'Money' or nil;
                            if Main and Owner and Money then
                                local O = tostring(Owner.Value);
                                local M = tostring(Money.Value);

                                pcall(RenderList.AddOrUpdateInstance, RenderList, v, Main, string.format('Money Printer\nOwned by %s\n[%s]', O, M), Color3.fromRGB(13, 255, 227));
                            end
                        end
                    end
                end;
            };
            -- [4581966615] = {
            -- 	CustomESP = function()
            -- 		if workspace:FindFirstChild'Entities' then
            -- 			for i, v in pairs(workspace.Entities:GetChildren()) do
            -- 				if not v.Name:match'Printer' then continue end

            -- 				local Properties = v:FindFirstChild'Properties' if not Properties then continue end
            -- 				local Main	= v:FindFirstChild'hitbox';
            -- 				local Owner	= Properties:FindFirstChild'Owner';
            -- 				local Money	= Properties:FindFirstChild'CurrentPrinted'
                            
            -- 				if Main and Owner and Money then
            -- 					local O = Owner.Value and tostring(Owner.Value) or 'no one';
            -- 					local M = tostring(Money.Value);

            -- 					pcall(RenderList.AddOrUpdateInstance, RenderList, v, Main, string.format('Money Printer\nOwned by %s\n[%s]', O, M), Color3.fromRGB(13, 255, 227));
            -- 				end
            -- 			end
            -- 		end
            -- 	end;
            -- };
            [4801598506] = {
                CustomESP = function()
                    if workspace:FindFirstChild'Mobs' and workspace.Mobs:FindFirstChild'Forest1' then
                        for i, v in pairs(workspace.Mobs.Forest1:GetChildren()) do
                            local Main	= v:FindFirstChild'Head';
                            local Hum	= v:FindFirstChild'Mob';

                            if Main and Hum then
                                pcall(RenderList.AddOrUpdateInstance, RenderList, v, Main, string.format('[%s] [%s/%s]', v.Name, Hum.Health, Hum.MaxHealth), Color3.fromRGB(13, 255, 227));
                            end
                        end
                    end
                end;
            };
            [2555873122] = {
                CustomESP = function()
                    if workspace:FindFirstChild'WoodPlanks' then
                        for i, v in pairs(workspace:GetChildren()) do
                            if v.Name == 'WoodPlanks' then
                                local Main = v:FindFirstChild'Wood';

                                if Main then
                                    pcall(RenderList.AddOrUpdateInstance, RenderList, v, Main, 'Wood Planks', Color3.fromRGB(13, 255, 227));
                                end
                            end
                        end
                    end
                end;
            };
            [5208655184] = {
                CustomESP = function()
                    -- if workspace:FindFirstChild'Live' then
                    -- 	for i, v in pairs(workspace.Live:GetChildren()) do
                    -- 		if v.Name:sub(1, 1) == '.' then
                    -- 			local Main = v:FindFirstChild'Head';

                    -- 			if Main then
                    -- 				pcall(RenderList.AddOrUpdateInstance, RenderList, v, Main, v.Name:sub(2), Color3.fromRGB(250, 50, 40));
                    -- 			end
                    -- 		end
                    -- 	end
                    -- end
                end;
                CustomPlayerTag = function(Player)
                    if game.PlaceVersion < 457 then return '' end

                    local Name = '';
                    local FirstName = Player:GetAttribute'FirstName'

                    if typeof(FirstName) == 'string' and #FirstName > 0 then
                        local Prefix = '';
                        local Extra = {};
                        Name = Name .. '\n[';

                        if Player:GetAttribute'Prestige' > 0 then
                            Name = Name .. '#' .. tostring(Player:GetAttribute'Prestige') .. ' ';
                        end
                        if not IsStringEmpty(Player:GetAttribute'HouseRank') then
                            Prefix = Player:GetAttribute'HouseRank' == 'Owner' and (Player:GetAttribute'Gender' == 'Female' and 'Lady ' or 'Lord ') or '';
                        end
                        if not IsStringEmpty(FirstName) then
                            Name = Name .. '' .. Prefix .. FirstName;
                        end
                        if not IsStringEmpty(Player:GetAttribute'LastName') then
                            Name = Name .. ' ' .. Player:GetAttribute'LastName';
                        end

                        if not IsStringEmpty(Name) then Name = Name .. ']'; end

                        local Character = GetCharacter(Player);

                        if Character then
                            if Character and Character:FindFirstChild'Danger' then table.insert(Extra, 'D'); end
                            if Character:FindFirstChild'ManaAbilities' and Character.ManaAbilities:FindFirstChild'ManaSprint' then table.insert(Extra, 'D1'); end

                            if Character:FindFirstChild'Mana'	 		then table.insert(Extra, 'M' .. math.floor(Character.Mana.Value)); end
                            if Character:FindFirstChild'Vampirism' 		then table.insert(Extra, 'V'); end
                            if Character:FindFirstChild'Observe'		then table.insert(Extra, 'ILL'); end
                            if Character:FindFirstChild'Inferi'			then table.insert(Extra, 'NEC'); end
                            if Character:FindFirstChild'World\'s Pulse' then table.insert(Extra, 'DZIN'); end
                            if Character:FindFirstChild'Shift'		 	then table.insert(Extra, 'MAD'); end
                            if Character:FindFirstChild'Head' and Character.Head:FindFirstChild'FacialMarking' then
                                local FM = Character.Head:FindFirstChild'FacialMarking';
                                if FM.Texture == 'http://www.roblox.com/asset/?id=4072968006' then
                                    table.insert(Extra, 'HEALER');
                                elseif FM.Texture == 'http://www.roblox.com/asset/?id=4072914434' then
                                    table.insert(Extra, 'SEER');
                                elseif FM.Texture == 'http://www.roblox.com/asset/?id=4094417635' then
                                    table.insert(Extra, 'JESTER');
                                elseif FM.Texture == 'http://www.roblox.com/asset/?id=4072968656' then
                                    table.insert(Extra, 'BLADE');
                                end
                            end
                        end
                        if Player:FindFirstChild'Backpack' then
                            if Player.Backpack:FindFirstChild'Observe' 			then table.insert(Extra, 'ILL');  end
                            if Player.Backpack:FindFirstChild'Inferi'			then table.insert(Extra, 'NEC');  end
                            if Player.Backpack:FindFirstChild'World\'s Pulse' 	then table.insert(Extra, 'DZIN'); end
                            if Player.Backpack:FindFirstChild'Shift'		 	then table.insert(Extra, 'MAD'); end
                        end

                        if #Extra > 0 then Name = Name .. ' [' .. table.concat(Extra, '-') .. ']'; end
                    end

                    return Name;
                end;
            };
            [3541987450] = {
                CustomPlayerTag = function(Player)
                    local Name = '';

                    if Player:FindFirstChild'leaderstats' then
                        Name = Name .. '\n[';
                        local Prefix = '';
                        local Extra = {};
                        if Player.leaderstats:FindFirstChild'Prestige' and Player.leaderstats.Prestige.ClassName == 'IntValue' and Player.leaderstats.Prestige.Value > 0 then
                            Name = Name .. '#' .. tostring(Player.leaderstats.Prestige.Value) .. ' ';
                        end
                        if Player.leaderstats:FindFirstChild'HouseRank' and Player.leaderstats:FindFirstChild'Gender' and Player.leaderstats.HouseRank.ClassName == 'StringValue' and not IsStringEmpty(Player.leaderstats.HouseRank.Value) then
                            Prefix = Player.leaderstats.HouseRank.Value == 'Owner' and (Player.leaderstats.Gender.Value == 'Female' and 'Lady ' or 'Lord ') or '';
                        end
                        if Player.leaderstats:FindFirstChild'FirstName' and Player.leaderstats.FirstName.ClassName == 'StringValue' and not IsStringEmpty(Player.leaderstats.FirstName.Value) then
                            Name = Name .. '' .. Prefix .. Player.leaderstats.FirstName.Value;
                        end
                        if Player.leaderstats:FindFirstChild'LastName' and Player.leaderstats.LastName.ClassName == 'StringValue' and not IsStringEmpty(Player.leaderstats.LastName.Value) then
                            Name = Name .. ' ' .. Player.leaderstats.LastName.Value;
                        end
                        if Player.leaderstats:FindFirstChild'UberTitle' and Player.leaderstats.UberTitle.ClassName == 'StringValue' and not IsStringEmpty(Player.leaderstats.UberTitle.Value) then
                            Name = Name .. ', ' .. Player.leaderstats.UberTitle.Value;
                        end

                        if not IsStringEmpty(Name) then Name = Name .. ']'; end

                        local Character = GetCharacter(Player);

                        if Character then
                            if Character and Character:FindFirstChild'Danger' then table.insert(Extra, 'D'); end
                            if Character:FindFirstChild'ManaAbilities' and Character.ManaAbilities:FindFirstChild'ManaSprint' then table.insert(Extra, 'D1'); end

                            if Character:FindFirstChild'Mana'	 		then table.insert(Extra, 'M' .. math.floor(Character.Mana.Value)); end
                            if Character:FindFirstChild'Vampirism' 		then table.insert(Extra, 'V');    end
                            if Character:FindFirstChild'Observe'			then table.insert(Extra, 'ILL');  end
                            if Character:FindFirstChild'Inferi'			then table.insert(Extra, 'NEC');  end
                            
                            if Character:FindFirstChild'World\'s Pulse' 	then table.insert(Extra, 'DZIN'); end
                            if Character:FindFirstChild'Head' and Character.Head:FindFirstChild'FacialMarking' then
                                local FM = Character.Head:FindFirstChild'FacialMarking';
                                if FM.Texture == 'http://www.roblox.com/asset/?id=4072968006' then
                                    table.insert(Extra, 'HEALER');
                                elseif FM.Texture == 'http://www.roblox.com/asset/?id=4072914434' then
                                    table.insert(Extra, 'SEER');
                                elseif FM.Texture == 'http://www.roblox.com/asset/?id=4094417635' then
                                    table.insert(Extra, 'JESTER');
                                end
                            end
                        end
                        if Player:FindFirstChild'Backpack' then
                            if Player.Backpack:FindFirstChild'Observe' 			then table.insert(Extra, 'ILL');  end
                            if Player.Backpack:FindFirstChild'Inferi'			then table.insert(Extra, 'NEC');  end
                            if Player.Backpack:FindFirstChild'World\'s Pulse' 	then table.insert(Extra, 'DZIN'); end
                        end

                        if #Extra > 0 then Name = Name .. ' [' .. table.concat(Extra, '-') .. ']'; end
                    end

                    return Name;
                end;
            };

            [4691401390] = { -- Vast Realm
                CustomCharacter = function(Player)
                    if workspace:FindFirstChild'Players' then
                        return workspace.Players:FindFirstChild(Player.Name);
                    end
                end
            };

            [6032399813] = { -- Deepwoken [Etrean]
                CustomPlayerTag = function(Player)
                    local Name = '';
                    CharacterName = Player:GetAttribute'CharacterName'; -- could use leaderstats but lazy

                    if not IsStringEmpty(CharacterName) then
                        Name = ('\n[%s]'):format(CharacterName);
                        local Character = GetCharacter(Player);
                        local Extra = {};

                        if Character then
                            local Blood, Armor = Character:FindFirstChild('Blood'), Character:FindFirstChild('Armor');

                            if Blood and Blood.ClassName == 'DoubleConstrainedValue' then
                                table.insert(Extra, ('B%d'):format(Blood.Value));
                            end

                            if Armor and Armor.ClassName == 'DoubleConstrainedValue' then
                                table.insert(Extra, ('A%d'):format(math.floor(Armor.Value / 10)));
                            end
                        end

                        local BackpackChildren = Player.Backpack:GetChildren()

                        for index = 1, #BackpackChildren do
                            local Oath = BackpackChildren[index]
                            if Oath.ClassName == 'Folder' and Oath.Name:find('Talent:Oath') then
                                local OathName = Oath.Name:gsub('Talent:Oath: ', '')
                                table.insert(Extra, OathName);
                            end
                        end

                        if #Extra > 0 then Name = Name .. ' [' .. table.concat(Extra, '-') .. ']'; end
                    end

                    return Name;
                end;
            };

            [5735553160] = { -- Deepwoken [Depths]
                CustomPlayerTag = function(Player)
                    local Name = '';
                    CharacterName = Player:GetAttribute'CharacterName'; -- could use leaderstats but lazy

                    if not IsStringEmpty(CharacterName) then
                        Name = ('\n[%s]'):format(CharacterName);
                        local Character = GetCharacter(Player);
                        local Extra = {};

                        if Character then
                            local Blood, Armor = Character:FindFirstChild('Blood'), Character:FindFirstChild('Armor');

                            if Blood and Blood.ClassName == 'DoubleConstrainedValue' then
                                table.insert(Extra, ('B%d'):format(Blood.Value));
                            end

                            if Armor and Armor.ClassName == 'DoubleConstrainedValue' then
                                table.insert(Extra, ('A%d'):format(math.floor(Armor.Value / 10)));
                            end
                        end

                        local BackpackChildren = Player.Backpack:GetChildren()

                        for index = 1, #BackpackChildren do
                            local Oath = BackpackChildren[index]
                            if Oath.ClassName == 'Folder' and Oath.Name:find('Talent:Oath') then
                                local OathName = Oath.Name:gsub('Talent:Oath: ', '')
                                table.insert(Extra, OathName);
                            end
                        end

                        if #Extra > 0 then Name = Name .. ' [' .. table.concat(Extra, '-') .. ']'; end
                    end

                    return Name;
                end;
            };

            [3127094264] = {
                CustomCharacter = function(Player)
                    if not _FIRST then
                        _FIRST = true
                        
                        pcall(function()
                            local GPM = rawget(require(LocalPlayer.PlayerScripts:WaitForChild('Client', 1e9):WaitForChild('Player', 1e9)), 'GetPlayerModel')
                            PList = debug.getupvalue(GPM, 1)
                        end)
                    end

                    if PList then
                        local Player = rawget(PList, Player.UserId)

                        if Player and Player.model then
                            return Player.model
                        end
                    end
                end
            }
        };

        if Modules[game.PlaceId] ~= nil or Modules[game.GameId] ~= nil then
            local Module = Modules[game.PlaceId] or Modules[game.GameId]

            if Module.Initialize then
                Module.Initialize()
            end

            CustomPlayerTag = Module.CustomPlayerTag or nil
            CustomESP = Module.CustomESP or nil
            CustomCharacter = Module.CustomCharacter or nil
            GetHealth = Module.GetHealth or nil
            GetAliveState = Module.GetAliveState or nil
            CustomRootPartName = Module.CustomRootPartName or nil
        end

        function GetCharacter(Player)
            return CustomCharacter and CustomCharacter(Player) or Player.Character
        end

        function GetMouseLocation()
            return UserInputService:GetMouseLocation();
        end

        function MouseHoveringOver(Values)
            local X1, Y1, X2, Y2 = Values[1], Values[2], Values[3], Values[4]
            local MLocation = GetMouseLocation();
            return (MLocation.x >= X1 and MLocation.x <= (X1 + (X2 - X1))) and (MLocation.y >= Y1 and MLocation.y <= (Y1 + (Y2 - Y1)));
        end

        function GetTableData(t) -- basically table.foreach i dont even know why i made this
            if typeof(t) ~= 'table' then return end

            return setmetatable(t, {
                __call = function(t, func)
                    if typeof(func) ~= 'function' then return end;
                    for i, v in pairs(t) do
                        pcall(func, i, v);
                    end
                end;
            });
        end
        local function Format(format, ...)
            return string.format(format, ...);
        end
        function CalculateValue(Min, Max, Percent)
            return Min + math.floor(((Max - Min) * Percent) + .5);
        end

        function NewDrawing(InstanceName)
            local Instance = Drawing.new(InstanceName)

            return (function(Properties)
                for i, v in pairs(Properties) do
                    pcall(Set, Instance, i, v)
                end

                return Instance
            end)
        end

        function Menu:AddMenuInstance(Name, DrawingType, Properties)
            local Instance;

            if shared.MenuDrawingData.Instances[Name] ~= nil then
                Instance = shared.MenuDrawingData.Instances[Name];
                for i, v in pairs(Properties) do
                    pcall(Set, Instance, i, v);
                end
            else
                Instance = NewDrawing(DrawingType)(Properties);
            end

            shared.MenuDrawingData.Instances[Name] = Instance;

            return Instance;
        end
        function Menu:UpdateMenuInstance(Name)
            local Instance = shared.MenuDrawingData.Instances[Name];
            if Instance ~= nil then
                return (function(Properties)
                    for i, v in pairs(Properties) do
                        pcall(Set, Instance, i, v);
                    end
                    return Instance;
                end)
            end
        end
        function Menu:GetInstance(Name)
            return shared.MenuDrawingData.Instances[Name];
        end

        local Options = setmetatable({}, {
            __call = function(t, ...)
                local Arguments = {...};
                local Name = Arguments[1];
                OIndex = OIndex + 1;
                rawset(t, Name, setmetatable({
                    Name			= Arguments[1];
                    Text			= Arguments[2];
                    Value			= Arguments[3];
                    DefaultValue	= Arguments[3];
                    AllArgs			= Arguments;
                    Index			= OIndex;
                }, {
                    __call = function(t, v, force)
                        local self = t;

                        if typeof(t.Value) == 'function' then
                            t.Value();
                        elseif typeof(t.Value) == 'EnumItem' then
                            local BT = Menu:GetInstance(Format('%s_BindText', t.Name));
                            if not force then
                                Binding = true;
                                local Val = 0
                                while Binding do
                                    wait();
                                    Val = (Val + 1) % 17;
                                    BT.Text = Val <= 8 and '|' or '';
                                end
                            end
                            t.Value = force and v or BindedKey;
                            if BT and t.BasePosition and t.BaseSize then
                                BT.Text = tostring(t.Value):match'%w+%.%w+%.(.+)';
                                BT.Position = t.BasePosition + V2New(t.BaseSize.X - BT.TextBounds.X - 20, -10);
                            end
                        else
                            local NewValue = v;
                            if NewValue == nil then NewValue = not t.Value; end
                            rawset(t, 'Value', NewValue);

                            if Arguments[2] ~= nil and Menu:GetInstance'TopBar'.Visible then
                                if typeof(Arguments[3]) == 'number' then
                                    local AMT = Menu:GetInstance(Format('%s_AmountText', t.Name));
                                    if AMT then
                                        AMT.Text = tostring(t.Value);
                                    end
                                else
                                    local Inner = Menu:GetInstance(Format('%s_InnerCircle', t.Name));
                                    if Inner then Inner.Visible = t.Value; end
                                end
                            end
                        end
                    end;
                }));
            end;
        })

        function Load()
            local _, Result = pcall(readfile, OptionsFile);
            
            if _ then -- extremely ugly code yea i know but i dont care p.s. i hate pcall
                local _, Table = pcall(HttpService.JSONDecode, HttpService, Result);
                if _ and typeof(Table) == 'table' then
                    for i, v in pairs(Table) do
                        if typeof(Options[i]) == 'table' and Options[i].Value ~= nil and (typeof(Options[i].Value) == 'boolean' or typeof(Options[i].Value) == 'number') then
                            Options[i].Value = v.Value;
                            pcall(Options[i], v.Value);
                        end
                    end

                    if Table.TeamColor then TeamColor = Color3.new(Table.TeamColor.R, Table.TeamColor.G, Table.TeamColor.B) end
                    if Table.EnemyColor then EnemyColor = Color3.new(Table.EnemyColor.R, Table.EnemyColor.G, Table.EnemyColor.B) end

                    if typeof(Table.MenuKey) == 'string' then Options.MenuKey(Enum.KeyCode[Table.MenuKey], true) end
                    if typeof(Table.ToggleKey) == 'string' then Options.ToggleKey(Enum.KeyCode[Table.ToggleKey], true) end
                end
            end
        end

        Options('Enabled', 'ESP Enabled', true);
        Options('ShowTeam', 'Show Team', true);
        Options('ShowTeamColor', 'Show Team Color', false);
        Options('ShowName', 'Show Names', true);
        Options('ShowDistance', 'Show Distance', true);
        Options('ShowHealth', 'Show Health', true);
        Options('ShowBoxes', 'Show Boxes', true);
        Options('ShowTracers', 'Show Tracers', true);
        Options('ShowDot', 'Show Head Dot', false);
        Options('VisCheck', 'Visibility Check', false);
        Options('Crosshair', 'Crosshair', false);
        Options('TextOutline', 'Text Outline', true);
        -- Options('Rainbow', 'Rainbow Mode', false);
        Options('TextSize', 'Text Size', syn and 18 or 14, 10, 24); -- cuz synapse fonts look weird???
        Options('MaxDistance', 'Max Distance', 2500, 100, 25000);
        Options('RefreshRate', 'Refresh Rate (ms)', 5, 1, 200);
        Options('YOffset', 'Y Offset', 0, -200, 200);
        Options('MenuKey', 'Menu Key', Enum.KeyCode.F4, 1);
        Options('ToggleKey', 'Toggle Key', Enum.KeyCode.F3, 1);
        Options('ChangeColors', SENTINEL_LOADED and 'Sentinel Unsupported' or 'Change Colors', function()
            if SENTINEL_LOADED then return end

            SubMenu:Show(GetMouseLocation(), 'Unnamed Colors', {
                {
                    Type = 'Color'; Text = 'Team Color'; Color = TeamColor;

                    Function = function(Circ, Position)
                        if tick() - ColorPicker.LastGenerated < 1 then return; end

                        if shared.CurrentColorPicker then shared.CurrentColorPicker:Dispose() end
                        local ColorPicker = ColorPicker.new(Position - V2New(-10, 50));
                        CurrentColorPicker = ColorPicker;
                        shared.CurrentColorPicker = CurrentColorPicker;
                        ColorPicker.ColorChanged:Connect(function(Color) Circ.Color = Color TeamColor = Color Options.TeamColor = Color end);
                    end
                };
                {
                    Type = 'Color'; Text = 'Enemy Color'; Color = EnemyColor;

                    Function = function(Circ, Position)
                        if tick() - ColorPicker.LastGenerated < 1 then return; end

                        if shared.CurrentColorPicker then shared.CurrentColorPicker:Dispose() end
                        local ColorPicker = ColorPicker.new(Position - V2New(-10, 50));
                        CurrentColorPicker = ColorPicker;
                        shared.CurrentColorPicker = CurrentColorPicker;
                        ColorPicker.ColorChanged:Connect(function(Color) Circ.Color = Color EnemyColor = Color Options.EnemyColor = Color end);
                    end
                };
                {
                    Type = 'Button'; Text = 'Reset Colors';

                    Function = function()
                        EnemyColor = Color3.new(1, 0, 0);
                        TeamColor = Color3.new(0, 1, 0);

                        local C1 = Menu:GetInstance'Sub-ColorPreview.1'; if C1 then C1.Color = TeamColor end
                        local C2 = Menu:GetInstance'Sub-ColorPreview.2'; if C2 then C2.Color = EnemyColor end
                    end
                };
                {
                    Type = 'Button'; Text = 'Rainbow Mode';

                    Function = function()
                        Rainbow = not Rainbow;
                    end
                };
            });
        end, 2);
        Options('ResetSettings', 'Reset Settings', function()
            for i, v in pairs(Options) do
                if Options[i] ~= nil and Options[i].Value ~= nil and Options[i].Text ~= nil and (typeof(Options[i].Value) == 'boolean' or typeof(Options[i].Value) == 'number' or typeof(Options[i].Value) == 'EnumItem') then
                    Options[i](Options[i].DefaultValue, true);
                end
            end
        end, 5);
        Options('LoadSettings', 'Load Settings', Load, 4);
        Options('SaveSettings', 'Save Settings', function()
            local COptions = {};

            for i, v in pairs(Options) do
                COptions[i] = v;
            end
            
            if typeof(TeamColor) == 'Color3' then COptions.TeamColor = { R = TeamColor.R; G = TeamColor.G; B = TeamColor.B } end
            if typeof(EnemyColor) == 'Color3' then COptions.EnemyColor = { R = EnemyColor.R; G = EnemyColor.G; B = EnemyColor.B } end
            
            if typeof(COptions.MenuKey.Value) == 'EnumItem' then COptions.MenuKey = COptions.MenuKey.Value.Name end
            if typeof(COptions.ToggleKey.Value) == 'EnumItem' then COptions.ToggleKey = COptions.ToggleKey.Value.Name end

            writefile(OptionsFile, HttpService:JSONEncode(COptions));
        end, 3);

        Load(1);

        Options('MenuOpen', nil, true);

        local function Combine(...)
            local Output = {};
            for i, v in pairs{...} do
                if typeof(v) == 'table' then
                    table.foreach(v, function(i, v)
                        Output[i] = v;
                    end)
                end
            end
            return Output
        end

        function LineBox:Create(Properties)
            local Box = { Visible = true }; -- prevent errors not really though dont worry bout the Visible = true thing

            local Properties = Combine({
                Transparency	= 1;
                Thickness		= 3;
                Visible			= true;
            }, Properties);

            if shared.am_ic3 then -- sory just my preference, dynamic boxes will be optional in unnamed esp v2
                Box['OutlineSquare']= NewDrawing'Square'(Properties);
                Box['Square'] 		= NewDrawing'Square'(Properties);
            elseif QUAD_SUPPORTED_EXPLOIT then
                Box['Quad']			= NewDrawing'Quad'(Properties);
            else
                Box['TopLeft']		= NewDrawing'Line'(Properties);
                Box['TopRight']		= NewDrawing'Line'(Properties);
                Box['BottomLeft']	= NewDrawing'Line'(Properties);
                Box['BottomRight']	= NewDrawing'Line'(Properties);
            end

            function Box:Update(CF, Size, Color, Properties, Parts)
                if not CF or not Size then return end

                if shared.am_ic3 and typeof(Parts) == 'table' then
                    local AllCorners = {};
                    
                    for i, v in pairs(Parts) do
                        -- if not v:IsA'BasePart' then continue end
                        
                        local CF, Size = v.CFrame, v.Size;
                        -- CF, Size = v.Parent:GetBoundingBox();

                        local Corners = {
                            Vector3.new(CF.X + Size.X / 2, CF.Y + Size.Y / 2, CF.Z + Size.Z / 2);
                            Vector3.new(CF.X - Size.X / 2, CF.Y + Size.Y / 2, CF.Z + Size.Z / 2);
                            Vector3.new(CF.X - Size.X / 2, CF.Y - Size.Y / 2, CF.Z - Size.Z / 2);
                            Vector3.new(CF.X + Size.X / 2, CF.Y - Size.Y / 2, CF.Z - Size.Z / 2);
                            Vector3.new(CF.X - Size.X / 2, CF.Y + Size.Y / 2, CF.Z - Size.Z / 2);
                            Vector3.new(CF.X + Size.X / 2, CF.Y + Size.Y / 2, CF.Z - Size.Z / 2);
                            Vector3.new(CF.X - Size.X / 2, CF.Y - Size.Y / 2, CF.Z + Size.Z / 2);
                            Vector3.new(CF.X + Size.X / 2, CF.Y - Size.Y / 2, CF.Z + Size.Z / 2);
                        };

                        for i, v in pairs(Corners) do
                            table.insert(AllCorners, v);
                        end

                        -- break
                    end

                    local xMin, yMin = Camera.ViewportSize.X, Camera.ViewportSize.Y;
                    local xMax, yMax = 0, 0;
                    local Vs = true;

                    for i, v in pairs(AllCorners) do				
                        local Position, V = WorldToViewport(v);

                        if VS and not V then Vs = false break end

                        if Position.X > xMax then
                            xMax = Position.X;
                        end
                        if Position.X < xMin then
                            xMin = Position.X;
                        end
                        if Position.Y > yMax then
                            yMax = Position.Y;
                        end
                        if Position.Y < yMin then
                            yMin = Position.Y;
                        end
                    end

                    local xSize, ySize = xMax - xMin, yMax - yMin;

                    local Outline = Box['OutlineSquare'];
                    local Square = Box['Square'];
                    Outline.Visible = Vs;
                    Square.Visible = Vs;
                    Square.Position = V2New(xMin, yMin);
                    Square.Color	= Color;
                    Square.Thickness = math.floor(Outline.Thickness * 0.3);
                    -- Square.Position = V2New(xMin, yMin);
                    Square.Size = V2New(xSize, ySize);
                    Outline.Position = Square.Position;
                    Outline.Size = Square.Size;
                    Outline.Color = Color3.new(0.12, 0.12, 0.12);
                    Outline.Transparency = 0.75;

                    return
                end
                
                local TLPos, Visible1	= WorldToViewport((CF * CFrame.new( Size.X,  Size.Y, 0)).Position);
                local TRPos, Visible2	= WorldToViewport((CF * CFrame.new(-Size.X,  Size.Y, 0)).Position);
                local BLPos, Visible3	= WorldToViewport((CF * CFrame.new( Size.X, -Size.Y, 0)).Position);
                local BRPos, Visible4	= WorldToViewport((CF * CFrame.new(-Size.X, -Size.Y, 0)).Position);

                local Quad = Box['Quad'];

                if QUAD_SUPPORTED_EXPLOIT then
                    if Visible1 and Visible2 and Visible3 and Visible4 then
                        Quad.Visible = true;
                        Quad.Color	= Color;
                        Quad.PointA = V2New(TLPos.X, TLPos.Y);
                        Quad.PointB = V2New(TRPos.X, TRPos.Y);
                        Quad.PointC = V2New(BRPos.X, BRPos.Y);
                        Quad.PointD = V2New(BLPos.X, BLPos.Y);
                    else
                        Box['Quad'].Visible = false;
                    end
                else
                    Visible1 = TLPos.Z > 0 -- (commented | reason: random flashes);
                    Visible2 = TRPos.Z > 0 -- (commented | reason: random flashes);
                    Visible3 = BLPos.Z > 0 -- (commented | reason: random flashes);
                    Visible4 = BRPos.Z > 0 -- (commented | reason: random flashes);

                    -- ## BEGIN UGLY CODE
                    if Visible1 then
                        Box['TopLeft'].Visible		= true;
                        Box['TopLeft'].Color		= Color;
                        Box['TopLeft'].From			= V2New(TLPos.X, TLPos.Y);
                        Box['TopLeft'].To			= V2New(TRPos.X, TRPos.Y);
                    else
                        Box['TopLeft'].Visible		= false;
                    end
                    if Visible2 then
                        Box['TopRight'].Visible		= true;
                        Box['TopRight'].Color		= Color;
                        Box['TopRight'].From		= V2New(TRPos.X, TRPos.Y);
                        Box['TopRight'].To			= V2New(BRPos.X, BRPos.Y);
                    else
                        Box['TopRight'].Visible		= false;
                    end
                    if Visible3 then
                        Box['BottomLeft'].Visible	= true;
                        Box['BottomLeft'].Color		= Color;
                        Box['BottomLeft'].From		= V2New(BLPos.X, BLPos.Y);
                        Box['BottomLeft'].To		= V2New(TLPos.X, TLPos.Y);
                    else
                        Box['BottomLeft'].Visible	= false;
                    end
                    if Visible4 then
                        Box['BottomRight'].Visible	= true;
                        Box['BottomRight'].Color	= Color;
                        Box['BottomRight'].From		= V2New(BRPos.X, BRPos.Y);
                        Box['BottomRight'].To		= V2New(BLPos.X, BLPos.Y);
                    else
                        Box['BottomRight'].Visible	= false;
                    end
                    if Properties and typeof(Properties) == 'table' then
                        GetTableData(Properties)(function(i, v)
                            pcall(Set, Box['TopLeft'],		i, v);
                            pcall(Set, Box['TopRight'],		i, v);
                            pcall(Set, Box['BottomLeft'],	i, v);
                            pcall(Set, Box['BottomRight'],	i, v);
                        end)
                    end
                    -- ## END UGLY CODE
                end
            end
            function Box:SetVisible(bool)
                if shared.am_ic3 then
                    Box['Square'].Visible = bool;
                    Box['OutlineSquare'].Visible = bool;
                elseif self.Quad then
                    self.Quad.Visible = false
                elseif self.TopLeft and self.TopRight and self.BottomLeft and self.BottomRight then
                    self.TopLeft.Visible = bool
                    self.TopRight.Visible = bool
                    self.BottomLeft.Visible = bool
                    self.BottomRight.Visible = bool
                end
            end
            function Box:Remove()
                self:SetVisible(false)

                if shared.am_ic3 then
                    Box['Square']:Remove()
                    Box['OutlineSquare']:Remove()
                elseif self.Quad then
                    Box['Quad']:Remove()
                elseif self.TopLeft and self.TopRight and self.BottomLeft and self.BottomRight then
                    self.TopLeft:Remove()
                    self.TopRight:Remove()
                    self.BottomLeft:Remove()
                    self.BottomRight:Remove()
                end
            end

            return Box;
        end

        local Colors = {
            White = Color3.fromHex'ffffff',
            Primary = {
                Main	= Color3.fromHex'424242',
                Light	= Color3.fromHex'6d6d6d',
                Dark	= Color3.fromHex'1b1b1b'
            },
            Secondary = {
                Main	= Color3.fromHex'e0e0e0',
                Light	= Color3.fromHex'ffffff',
                Dark	= Color3.fromHex'aeaeae'
            }
        }

        function Connections:Listen(Connection, Function)
            local NewConnection = Connection:Connect(Function);
            table.insert(self.Active, NewConnection);
            return NewConnection;
        end

        function Connections:DisconnectAll()
            for Index, Connection in pairs(self.Active) do
                if Connection.Connected then
                    Connection:Disconnect();
                end
            end
            
            self.Active = {};
        end

        function Signal.new()
            local self = setmetatable({ _BindableEvent = Instance.new'BindableEvent' }, Signal);
            
            return self;
        end

        function Signal:Connect(Callback)
            assert(typeof(Callback) == 'function', 'function expected; got ' .. typeof(Callback));

            return self._BindableEvent.Event:Connect(function(...) Callback(...) end);
        end

        function Signal:Fire(...)
            self._BindableEvent:Fire(...);
        end

        function Signal:Wait()
            local Arguments = self._BindableEvent:Wait();

            return Arguments;
        end

        function Signal:Disconnect()
            if self._BindableEvent then
                self._BindableEvent:Destroy();
            end
        end

        local function GetMouseLocation()
            return UserInputService:GetMouseLocation();
        end

        local function IsMouseOverDrawing(Drawing, MousePosition)
            local TopLeft = Drawing.Position;
            local BottomRight = Drawing.Position + Drawing.Size;
            local MousePosition = MousePosition or GetMouseLocation();
            
            return MousePosition.X > TopLeft.X and MousePosition.Y > TopLeft.Y and MousePosition.X < BottomRight.X and MousePosition.Y < BottomRight.Y;
        end

        local ImageCache = {};

        local function SetImage(Drawing, Url)
            local Data = IsSynapse and game:HttpGet(Url) or Url;

            Drawing[IsSynapse and 'Data' or 'Uri'] = ImageCache[Url] or Data;
            ImageCache[Url] = Data;
            
            if not IsSynapse then repeat wait() until Drawing.Loaded; end
        end

        -- oh god unnamed esp needs an entire rewrite, someone make a better one pls im too lazy
        -- btw the color picker was made seperately so it doesnt fit with the code of unnamed esp

        local function CreateDrawingsTable()
            local Drawings = { __Objects = {} };
            local Metatable = {};

            function Metatable.__index(self, Index)
                local Object = rawget(self.__Objects, Index);
                
                if not Object or (IsSynapse and not Object.__SELF.__OBJECT_EXISTS) then
                    local Type = Index:sub(1, Index:find'-' - 1);

                    Success, Object = pcall(Drawing.new, Type);

                    if not Object or not Success then return function() end; end

                    self.__Objects[Index] = setmetatable({ __SELF = Object; Type = Type }, {
                        __call = function(self, Properties)
                            local Object = rawget(self, '__SELF'); if IsSynapse and not Object.__OBJECT_EXISTS then return false, 'render object destroyed'; end

                            if Properties == false then
                                Object.Visible = false;
                                Object.Transparency = 0;
                                Object:Remove();
                                
                                return true;
                            end
                            
                            if typeof(Properties) == 'table' then
                                for Property, Value in pairs(Properties) do
                                    local CanSet = true;

                                    if self.Type == 'Image' and not IsSynapse and Property == 'Size' and typeof(Value) == 'Vector2' then
                                        CanSet = false;

                                        spawn(function()
                                            repeat wait() until Object.Loaded;
                                            if not self.DefaultSize then rawset(self, 'DefaultSize', Object.Size) end

                                            Property = 'ScaleFactor';
                                            Value = Value.X / self.DefaultSize.X;

                                            Object[Property] = Value
                                        end)
                                    end
                                    
                                    if CanSet then Object[Property] = Value end
                                end
                            end

                            return Object;
                        end
                    });

                    Object.Visible = true;
                    Object.Transparency = 1; -- Transparency is really Opacity with drawing api (1 being visible, 0 being invisible)
                    
                    if Type == 'Text' then
                        if Drawing.Fonts then Object.Font = Drawing.Fonts.Monospace end
                        Object.Size = 20;
                        Object.Color = Color3.new(1, 1, 1);
                        Object.Center = true;
                        Object.Outline = true;
                        OutlineOpacity = 0.5;
                    elseif Type == 'Square' or Type == 'Rectangle' then
                        Object.Thickness = 2;
                        Object.Filled = false;
                    end

                    return self.__Objects[Index];
                end

                return Object;
            end

            function Metatable.__call(self, Delete, ...)
                local Arguments = {Delete, ...};
                
                if Delete == false then
                    for Index, Drawing in pairs(rawget(self, '__Objects')) do
                        Drawing(false);
                    end
                end
            end

            return setmetatable(Drawings, Metatable);
        end

        local Images = {}

        spawn(function()
            Images.Ring = 'https://i.imgur.com/q4qx26f.png'
            Images.Overlay = 'https://i.imgur.com/gOCxbsR.png'
        end)

        function ColorPicker.new(Position, Size, Color)
            ColorPicker.LastGenerated = tick();
            ColorPicker.Loading = true;

            local self = { Color = Color or Color3.new(1, 1, 1); HSV = { H = 0, S = 1, V = 1 } };
            local Drawings = CreateDrawingsTable();
            local Position = Position or V2New();
            local Size = Size or 150;
            local Padding = { 10, 10, 10, 10 };
            
            self.ColorChanged = Signal.new();

            local Background = Drawings['Square-Background'] {
                Color = Color3.fromRGB(33, 33, 33);
                Filled = false;
                Visible = false;
                Position = Position - V2New(Padding[4], Padding[1]);
                Size = V2New(Size, Size) + V2New(Padding[4] + Padding[2], Padding[1] + Padding[3]);
            };
            local ColorPreview = Drawings['Circle-Preview'] {
                Position = Position + (V2New(Size, Size) / 2);
                Radius = Size / 2 - 8;
                Filled = true;
                Thickness = 0;
                NumSides = 20;
                Color = Color3.new(1, 0, 0);
            };
            local Main = Drawings['Image-Main'] {
                Position = Position;
                Size = V2New(Size, Size);
            }; SetImage(Main, Images.Ring);
            local Preview = Drawings['Square-Preview'] {
                Position = Main.Position + (Main.Size / 4.5);
                Size = Main.Size / 1.75;
                Color = Color3.new(1, 0, 0);
                Filled = true;
                Thickness = 0;
            };
            local Overlay = Drawings['Image-Overlay'] {
                Position = Preview.Position;
                Size = Preview.Size;
                Transparency = 1;
            }; SetImage(Overlay, Images.Overlay);
            local CursorOutline = Drawings['Circle-CursorOutline'] {
                Radius = 4;
                Thickness = 2;
                Filled = false;
                Color = Color3.new(0.2, 0.2, 0.2);
                Position = V2New(Main.Position.X + Main.Size.X - 10, Main.Position.Y + (Main.Size.Y / 2));
            };
            local Cursor = Drawings['Circle-Cursor'] {
                Radius = 3;
                Transparency = 1;
                Filled = true;
                Color = Color3.new(1, 1, 1);
                Position = CursorOutline.Position;
            };
            local CursorOutline = Drawings['Circle-CursorOutlineSquare'] {
                Radius = 4;
                Thickness = 2;
                Filled = false;
                Color = Color3.new(0.2, 0.2, 0.2);
                Position = V2New(Preview.Position.X + Preview.Size.X - 2, Preview.Position.Y + 2);
            };
            Drawings['Circle-CursorSquare'] {
                Radius = 3;
                Transparency = 1;
                Filled = true;
                Color = Color3.new(1, 1, 1);
                Position = CursorOutline.Position;
            };
            
            function self:UpdatePosition(Input)
                local MousePosition = V2New(Input.Position.X, Input.Position.Y + 33);

                if self.MouseHeld then
                    if self.Item == 'Ring' then
                        local Main = self.Drawings['Image-Main'] ();
                        local Preview = self.Drawings['Square-Preview'] ();
                        local Bounds = Main.Size / 2;
                        local Center = Main.Position + Bounds;
                        local Relative = MousePosition - Center;
                        local Direction = Relative.unit;
                        local Position = Center + Direction * Main.Size.X / 2.15;
                        local H = (math.atan2(Position.Y - Center.Y, Position.X - Center.X)) * 60;
                        if H < 0 then H = 360 + H; end
                        H = H / 360;
                        self.HSV.H = H;
                        local EndColor = Color3.fromHSV(H, self.HSV.S, self.HSV.V); if EndColor ~= self.Color then self.ColorChanged:Fire(self.Color); end
                        local Pointer = self.Drawings['Circle-Cursor'] { Position = Position };
                        self.Drawings['Circle-CursorOutline'] { Position = Pointer.Position };
                        Bounds = Bounds * 2;
                        Preview.Color = Color3.fromHSV(H, 1, 1);
                        self.Color = EndColor;
                        self.Drawings['Circle-Preview'] { Color = EndColor };
                    elseif self.Item == 'HL' then
                        local Preview = self.Drawings['Square-Preview'] ();
                        local HSV = self.HSV;
                        local Position = V2New(math.clamp(MousePosition.X, Preview.Position.X, Preview.Position.X + Preview.Size.X), math.clamp(MousePosition.Y, Preview.Position.Y, Preview.Position.Y + Preview.Size.Y));
                        HSV.S = (Position.X - Preview.Position.X) / Preview.Size.X;
                        HSV.V = 1 - (Position.Y - Preview.Position.Y) / Preview.Size.Y;
                        local EndColor = Color3.fromHSV(HSV.H, HSV.S, HSV.V); if EndColor ~= self.Color then self.ColorChanged:Fire(self.Color); end
                        self.Color = EndColor;
                        self.Drawings['Circle-Preview'] { Color = EndColor };
                        local Pointer = self.Drawings['Circle-CursorSquare'] { Position = Position };
                        self.Drawings['Circle-CursorOutlineSquare'] { Position = Pointer.Position };
                    end
                end
            end

            function self:HandleInput(Input, P, Type)
                if Type == 'Began' then
                    if Input.UserInputType.Name == 'MouseButton1' then
                        local Main = self.Drawings['Image-Main'] ();
                        local SquareSV = self.Drawings['Square-Preview'] ();
                        local MousePosition = V2New(Input.Position.X, Input.Position.Y + 33);
                        self.MouseHeld = true;
                        local Bounds = Main.Size / 2;
                        local Center = Main.Position + Bounds;
                        local R = (MousePosition - Center);
                
                        if R.Magnitude < Bounds.X and R.Magnitude > Bounds.X - 20 then
                            self.Item = 'Ring';
                        end
                        
                        if MousePosition.X > SquareSV.Position.X and MousePosition.Y > SquareSV.Position.Y and MousePosition.X < SquareSV.Position.X + SquareSV.Size.X and MousePosition.Y < SquareSV.Position.Y + SquareSV.Size.Y then
                            self.Item = 'HL';
                        end

                        self:UpdatePosition(Input, P);
                    end
                elseif Type == 'Changed' then
                    if Input.UserInputType.Name == 'MouseMovement' then
                        self:UpdatePosition(Input, P);
                    end
                elseif Type == 'Ended' and Input.UserInputType.Name == 'MouseButton1' then
                    self.Item = nil;
                end
            end
            
            function self:Dispose()
                self.Drawings(false);
                self.UpdatePosition = nil;
                self.HandleInput = nil;
                Connections:DisconnectAll(); -- scuffed tbh
            end

            Connections:Listen(UserInputService.InputBegan, function(Input, Process)
                self:HandleInput(Input, Process, 'Began');
            end);
            Connections:Listen(UserInputService.InputChanged, function(Input, Process)
                if Input.UserInputType.Name == 'MouseMovement' then
                    local MousePosition = V2New(Input.Position.X, Input.Position.Y + 33);
                    local Cursor = self.Drawings['Triangle-Cursor'] {
                        Filled = true;
                        Color = Color3.new(0.9, 0.9, 0.9);
                        PointA = MousePosition + V2New(0, 0);
                        PointB = MousePosition + V2New(12, 14);
                        PointC = MousePosition + V2New(0, 18);
                        Thickness = 0;
                    };
                end
                self:HandleInput(Input, Process, 'Changed');
            end);
            Connections:Listen(UserInputService.InputEnded, function(Input, Process)
                self:HandleInput(Input, Process, 'Ended');
                
                if Input.UserInputType.Name == 'MouseButton1' then
                    self.MouseHeld = false
                end
            end)

            ColorPicker.Loading = false

            self.Drawings = Drawings

            return self
        end

        function SubMenu:Show(Position, Title, Options)
            self.Open = true;

            local Visible = true;
            local BasePosition = Position;
            local BaseSize = V2New(200, 140);
            local End = BasePosition + BaseSize;

            self.Bounds = { BasePosition.X, BasePosition.Y, End.X, End.Y };

            delay(0.025, function()
                if not self.Open then return; end

                Menu:AddMenuInstance('Sub-Main', 'Square', {
                    Size		= BaseSize;
                    Position	= BasePosition;
                    Filled		= false;
                    Color		= Colors.Primary.Main;
                    Thickness	= 3;
                    Visible		= Visible;
                });
            end);
            Menu:AddMenuInstance('Sub-TopBar', 'Square', {
                Position	= BasePosition;
                Size		= V2New(BaseSize.X, 10);
                Color		= Colors.Primary.Dark;
                Filled		= true;
                Visible		= Visible;
            });
            Menu:AddMenuInstance('Sub-TopBarTwo', 'Square', {
                Position 	= BasePosition + V2New(0, 10);
                Size		= V2New(BaseSize.X, 20);
                Color		= Colors.Primary.Main;
                Filled		= true;
                Visible		= Visible;
            });
            Menu:AddMenuInstance('Sub-TopBarText', 'Text', {
                Size 		= 20;
                Position	= shared.MenuDrawingData.Instances['Sub-TopBarTwo'].Position + V2New(15, -3);
                Text		= Title or '';
                Color		= Colors.Secondary.Light;
                Visible		= Visible;
            });
            Menu:AddMenuInstance('Sub-Filling', 'Square', {
                Size		= BaseSize - V2New(0, 30);
                Position	= BasePosition + V2New(0, 30);
                Filled		= true;
                Color		= Colors.Secondary.Main;
                Transparency= .75;
                Visible		= Visible;
            });

            if Options then
                for Index, Option in pairs(Options) do -- currently only supports color and button(but color is a button so), planning on fully rewriting or something
                    local function GetName(Name) return ('Sub-%s.%d'):format(Name, Index) end
                    local Position = shared.MenuDrawingData.Instances['Sub-Filling'].Position + V2New(20, Index * 25 - 10);
                    -- local BasePosition	= shared.MenuDrawingData.Instances.Filling.Position + V2New(30, v.Index * 25 - 10);

                    if Option.Type == 'Color' then
                        local ColorPreview = Menu:AddMenuInstance(GetName'ColorPreview', 'Circle', {
                            Position = Position;
                            Color = Option.Color;
                            Radius = IsSynapse and 10 or 10;
                            NumSides = 10;
                            Filled = true;
                            Visible = true;
                        });
                        local Text = Menu:AddMenuInstance(GetName'Text', 'Text', {
                            Text = Option.Text;
                            Position = ColorPreview.Position + V2New(15, -8);
                            Size = 16;
                            Color = Colors.Primary.Dark;
                            Visible = true;
                        });
                        UIButtons[#UIButtons + 1] = {
                            FromSubMenu = true;
                            Option = function() return Option.Function(ColorPreview, BasePosition + V2New(BaseSize.X, 0)) end;
                            Instance = Menu:AddMenuInstance(Format('%s_Hitbox', GetName'Button'), 'Square', {
                                Position	= Position - V2New(20, 12);
                                Size		= V2New(BaseSize.X, 25);
                                Visible		= false;
                            });
                        };
                    elseif Option.Type == 'Button' then
                        UIButtons[#UIButtons + 1] = {
                            FromSubMenu = true;
                            Option = Option.Function;
                            Instance = Menu:AddMenuInstance(Format('%s_Hitbox', GetName'Button'), 'Square', {
                                Size		= V2New(BaseSize.X, 20) - V2New(20, 0);
                                Visible		= true;
                                Transparency= .5;
                                Position	= Position - V2New(10, 10);
                                Color		= Colors.Secondary.Light;
                                Filled		= true;
                            });
                        };
                        local Text		= Menu:AddMenuInstance(Format('%s_Text', GetName'Text'), 'Text', {
                            Text		= Option.Text;
                            Size		= 18;
                            Position	= Position + V2New(5, -10);
                            Visible		= true;
                            Color		= Colors.Primary.Dark;
                        });
                    end
                end
            end
        end

        function SubMenu:Hide()
            self.Open = false;

            for i, v in pairs(shared.MenuDrawingData.Instances) do
                if i:sub(1, 3) == 'Sub' then
                    v.Visible = false;

                    if i:sub(4, 4) == ':' then -- ';' = Temporary so remove
                        v:Remove();
                        shared.MenuDrawingData.Instance[i] = nil;
                    end
                end
            end

            for i, Button in pairs(UIButtons) do
                if Button.FromSubMenu then
                    UIButtons[i] = nil;
                end
            end

            spawn(function() -- stupid bug happens if i dont use this
                for i = 1, 10 do
                    if shared.CurrentColorPicker then -- dont know why 'CurrentColorPicker' isnt a variable in this
                        shared.CurrentColorPicker:Dispose();
                    end
                    wait(0.1);
                end
            end)

            CurrentColorPicker = nil;
        end

        function CreateMenu(NewPosition) -- Create Menu
            MenuLoaded = false;
            UIButtons  = {};
            Sliders	   = {};

            local BaseSize = V2New(300, 625);
            local BasePosition = NewPosition or V2New(Camera.ViewportSize.X / 8 - (BaseSize.X / 2), Camera.ViewportSize.Y / 2 - (BaseSize.Y / 2));

            BasePosition = V2New(math.clamp(BasePosition.X, 0, Camera.ViewportSize.X), math.clamp(BasePosition.Y, 0, Camera.ViewportSize.Y));

            Menu:AddMenuInstance('CrosshairX', 'Line', {
                Visible			= false;
                Color			= Color3.new(0, 1, 0);
                Transparency	= 1;
                Thickness		= 1;
            });
            Menu:AddMenuInstance('CrosshairY', 'Line', {
                Visible			= false;
                Color			= Color3.new(0, 1, 0);
                Transparency	= 1;
                Thickness		= 1;
            });

            delay(.025, function() -- since zindex doesnt exist
                Menu:AddMenuInstance('Main', 'Square', {
                    Size		= BaseSize;
                    Position	= BasePosition;
                    Filled		= false;
                    Color		= Colors.Primary.Main;
                    Thickness	= 3;
                    Visible		= true;
                });
            end);
            Menu:AddMenuInstance('TopBar', 'Square', {
                Position	= BasePosition;
                Size		= V2New(BaseSize.X, 15);
                Color		= Colors.Primary.Dark;
                Filled		= true;
                Visible		= true;
            });
            Menu:AddMenuInstance('TopBarTwo', 'Square', {
                Position 	= BasePosition + V2New(0, 15);
                Size		= V2New(BaseSize.X, 45);
                Color		= Colors.Primary.Main;
                Filled		= true;
                Visible		= true;
            });
            Menu:AddMenuInstance('TopBarText', 'Text', {
                Size 		= 25;
                Position	= shared.MenuDrawingData.Instances.TopBarTwo.Position + V2New(25, 10);
                Text		= 'ESP';
                Color		= Colors.Secondary.Light;
                Visible		= true;
                Transparency= 1; -- proto outline fix
                Outline 	= true;
                OutlineOpacity = 0.5;
            });
            Menu:AddMenuInstance('TopBarTextBR', 'Text', {
                Size 		= 18;
                Position	= shared.MenuDrawingData.Instances.TopBarTwo.Position + V2New(BaseSize.X - 75, 25);
                Text		= 'by Umvtt';
                Color		= Colors.Secondary.Light;
                Visible		= true;
                Transparency= 1;
                Outline 	= true;
                OutlineOpacity = 0.5;
            });
            Menu:AddMenuInstance('Filling', 'Square', {
                Size		= BaseSize - V2New(0, 60);
                Position	= BasePosition + V2New(0, 60);
                Filled		= true;
                Color		= Colors.Secondary.Main;
                Transparency= .35;
                Visible		= true;
            });

            local CPos = 0;

            GetTableData(Options)(function(i, v)
                if typeof(v.Value) == 'boolean' and not IsStringEmpty(v.Text) and v.Text ~= nil then
                    CPos 				= CPos + 25;
                    local BaseSize		= V2New(BaseSize.X, 30);
                    local BasePosition	= shared.MenuDrawingData.Instances.Filling.Position + V2New(30, v.Index * 25 - 10);
                    UIButtons[#UIButtons + 1] = {
                        Option = v;
                        Instance = Menu:AddMenuInstance(Format('%s_Hitbox', v.Name), 'Square', {
                            Position	= BasePosition - V2New(30, 15);
                            Size		= BaseSize;
                            Visible		= false;
                        });
                    };
                    Menu:AddMenuInstance(Format('%s_OuterCircle', v.Name), 'Circle', {
                        Radius		= 10;
                        Position	= BasePosition;
                        Color		= Colors.Secondary.Light;
                        Filled		= true;
                        Visible		= true;
                    });
                    Menu:AddMenuInstance(Format('%s_InnerCircle', v.Name), 'Circle', {
                        Radius		= 7;
                        Position	= BasePosition;
                        Color		= Colors.Secondary.Dark;
                        Filled		= true;
                        Visible		= v.Value;
                    });
                    Menu:AddMenuInstance(Format('%s_Text', v.Name), 'Text', {
                        Text		= v.Text;
                        Size		= 20;
                        Position	= BasePosition + V2New(20, -10);
                        Visible		= true;
                        Color		= Colors.Secondary.Light;
                        Transparency= 1;
                        Outline		= true;
                        OutlineOpacity = 0.5;
                    });
                end
            end)
            GetTableData(Options)(function(i, v) -- just to make sure certain things are drawn before or after others, too lazy to actually sort table
                if typeof(v.Value) == 'number' then
                    CPos 				= CPos + 25;

                    local BaseSize		= V2New(BaseSize.X, 30);
                    local BasePosition	= shared.MenuDrawingData.Instances.Filling.Position + V2New(0, CPos - 10);

                    local Line			= Menu:AddMenuInstance(Format('%s_SliderLine', v.Name), 'Square', {
                        Transparency	= 1;
                        Color			= Colors.Secondary.Light;
                        -- Thickness		= 3;
                        Filled			= true;
                        Visible			= true;
                        Position 		= BasePosition + V2New(15, -5);
                        Size 			= BaseSize - V2New(30, 10);
                        Transparency	= 0.5;
                    });
                    local Slider		= Menu:AddMenuInstance(Format('%s_Slider', v.Name), 'Square', {
                        Visible			= true;
                        Filled			= true;
                        Color			= Colors.Primary.Dark;
                        Size			= V2New(5, Line.Size.Y);
                        Transparency	= 0.5;
                    });
                    local Text			= Menu:AddMenuInstance(Format('%s_Text', v.Name), 'Text', {
                        Text			= v.Text;
                        Size			= 20;
                        Center			= true;
                        Transparency	= 1;
                        Outline			= true;
                        OutlineOpacity  = 0.5;
                        Visible			= true;
                        Color			= Colors.White;
                    }); Text.Position	= Line.Position + (Line.Size / 2) - V2New(0, Text.TextBounds.Y / 1.75);
                    local AMT			= Menu:AddMenuInstance(Format('%s_AmountText', v.Name), 'Text', {
                        Text			= tostring(v.Value);
                        Size			= 22;
                        Center			= true;
                        Transparency	= 1;
                        Outline			= true;
                        OutlineOpacity  = 0.5;
                        Visible			= true;
                        Color			= Colors.White;
                        Position		= Text.Position;
                    });

                    local CSlider = {Slider = Slider; Line = Line; Min = v.AllArgs[4]; Max = v.AllArgs[5]; Option = v};
                    local Dummy = Instance.new'NumberValue';

                    Dummy:GetPropertyChangedSignal'Value':Connect(function()
                        Text.Transparency = Dummy.Value;
                        -- Text.OutlineTransparency = 1 - Dummy.Value;
                        AMT.Transparency = 1 - Dummy.Value;
                    end);

                    Dummy.Value = 1;

                    function CSlider:ShowValue(Bool)
                        self.ShowingValue = Bool;

                        TweenService:Create(Dummy, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), { Value = Bool and 0 or 1 }):Play();
                    end

                    Sliders[#Sliders + 1] = CSlider;

                    -- local Percent = (v.Value / CSlider.Max) * 100;
                    -- local Size = math.abs(Line.From.X - Line.To.X);
                    -- local Value = Size * (Percent / 100); -- this shit's inaccurate but fuck it i'm not even gonna bother fixing it

                    Slider.Position = Line.Position + V2New(35, 0);
                    
                    v.BaseSize = BaseSize;
                    v.BasePosition = BasePosition;
                    -- AMT.Position = BasePosition + V2New(BaseSize.X - AMT.TextBounds.X - 10, -10)
                end
            end)
            local FirstItem = false;
            GetTableData(Options)(function(i, v) -- just to make sure certain things are drawn before or after others, too lazy to actually sort table
                if typeof(v.Value) == 'EnumItem' then
                    CPos 				= CPos + (not FirstItem and 30 or 25);
                    FirstItem			= true;

                    local BaseSize		= V2New(BaseSize.X, FirstItem and 30 or 25);
                    local BasePosition	= shared.MenuDrawingData.Instances.Filling.Position + V2New(0, CPos - 10);

                    UIButtons[#UIButtons + 1] = {
                        Option = v;
                        Instance = Menu:AddMenuInstance(Format('%s_Hitbox', v.Name), 'Square', {
                            Size		= V2New(BaseSize.X, 20) - V2New(30, 0);
                            Visible		= true;
                            Transparency= .5;
                            Position	= BasePosition + V2New(15, -10);
                            Color		= Colors.Secondary.Light;
                            Filled		= true;
                        });
                    };
                    local Text		= Menu:AddMenuInstance(Format('%s_Text', v.Name), 'Text', {
                        Text		= v.Text;
                        Size		= 20;
                        Position	= BasePosition + V2New(20, -10);
                        Visible		= true;
                        Color		= Colors.Secondary.Light;
                        Transparency= 1;
                        Outline		= true;
                        OutlineOpacity = 0.5;
                    });
                    local BindText	= Menu:AddMenuInstance(Format('%s_BindText', v.Name), 'Text', {
                        Text		= tostring(v.Value):match'%w+%.%w+%.(.+)';
                        Size		= 20;
                        Position	= BasePosition;
                        Visible		= true;
                        Color		= Colors.Secondary.Light;
                        Transparency= 1;
                        Outline		= true;
                        OutlineOpacity = 0.5;
                    });

                    Options[i].BaseSize = BaseSize;
                    Options[i].BasePosition = BasePosition;
                    BindText.Position = BasePosition + V2New(BaseSize.X - BindText.TextBounds.X - 20, -10);
                end
            end)
            GetTableData(Options)(function(i, v) -- just to make sure certain things are drawn before or after others, too lazy to actually sort table
                if typeof(v.Value) == 'function' then
                    local BaseSize		= V2New(BaseSize.X, 30);
                    local BasePosition	= shared.MenuDrawingData.Instances.Filling.Position + V2New(0, CPos + (25 * v.AllArgs[4]) - 35);

                    UIButtons[#UIButtons + 1] = {
                        Option = v;
                        Instance = Menu:AddMenuInstance(Format('%s_Hitbox', v.Name), 'Square', {
                            Size		= V2New(BaseSize.X, 20) - V2New(30, 0);
                            Visible		= true;
                            Transparency= .5;
                            Position	= BasePosition + V2New(15, -10);
                            Color		= Colors.Secondary.Light;
                            Filled		= true;
                        });
                    };
                    local Text		= Menu:AddMenuInstance(Format('%s_Text', v.Name), 'Text', {
                        Text		= v.Text;
                        Size		= 20;
                        Position	= BasePosition + V2New(20, -10);
                        Visible		= true;
                        Color		= Colors.Secondary.Light;
                        Transparency= 1;
                        Outline		= true;
                        OutlineOpacity = 0.5;
                    });

                    -- BindText.Position = BasePosition + V2New(BaseSize.X - BindText.TextBounds.X - 10, -10);
                end
            end)

            delay(.1, function()
                MenuLoaded = true;
            end);

            -- this has to be at the bottom cuz proto drawing api doesnt have zindex :triumph:	
            Menu:AddMenuInstance('Cursor1', 'Line', {
                Visible			= false;
                Color			= Color3.new(1, 0, 0);
                Transparency	= 1;
                Thickness		= 2;
            });
            Menu:AddMenuInstance('Cursor2', 'Line', {
                Visible			= false;
                Color			= Color3.new(1, 0, 0);
                Transparency	= 1;
                Thickness		= 2;
            });
            Menu:AddMenuInstance('Cursor3', 'Line', {
                Visible			= false;
                Color			= Color3.new(1, 0, 0);
                Transparency	= 1;
                Thickness		= 2;
            });
        end

        CreateMenu();
        delay(0.1, function()
            SubMenu:Show(V2New()); -- Create the submenu
            SubMenu:Hide();
        end);

        shared.UESP_InputChangedCon = UserInputService.InputChanged:Connect(function(input)
            if input.UserInputType.Name == 'MouseMovement' and Options.MenuOpen.Value then
                for i, v in pairs(Sliders) do
                    local Values = {
                        v.Line.Position.X;
                        v.Line.Position.Y;
                        v.Line.Position.X + v.Line.Size.X;
                        v.Line.Position.Y + v.Line.Size.Y;
                    };
                    if MouseHoveringOver(Values) then
                        v:ShowValue(true);
                    else
                        if not MouseHeld then v:ShowValue(false); end
                    end
                end
            end
        end)
        shared.UESP_InputBeganCon = UserInputService.InputBegan:Connect(function(input)
            if input.UserInputType.Name == 'MouseButton1' and Options.MenuOpen.Value then
                MouseHeld = true;
                local Bar = Menu:GetInstance'TopBar';
                local Values = {
                    Bar.Position.X;
                    Bar.Position.Y;
                    Bar.Position.X + Bar.Size.X;
                    Bar.Position.Y + Bar.Size.Y;
                }
                if MouseHoveringOver(Values) then
                    DraggingUI = true;
                    DragOffset = Menu:GetInstance'Main'.Position - GetMouseLocation();
                else
                    for i, v in pairs(Sliders) do
                        local Values = {
                            v.Line.Position.X;
                            v.Line.Position.Y;
                            v.Line.Position.X + v.Line.Size.X;
                            v.Line.Position.Y + v.Line.Size.Y;
                            -- v.Line.From.X	- (v.Slider.Radius);
                            -- v.Line.From.Y	- (v.Slider.Radius);
                            -- v.Line.To.X		+ (v.Slider.Radius);
                            -- v.Line.To.Y		+ (v.Slider.Radius);
                        };
                        if MouseHoveringOver(Values) then
                            DraggingWhat = v;
                            Dragging = true;
                            break
                        end
                    end

                    if not Dragging then
                        local Values = {
                            TracerPosition.X - 10;
                            TracerPosition.Y - 10;
                            TracerPosition.X + 10;
                            TracerPosition.Y + 10;
                        };
                        if MouseHoveringOver(Values) then
                            DragTracerPosition = true;
                        end
                    end
                end
            end
        end)
        shared.UESP_InputEndedCon = UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType.Name == 'MouseButton1' and Options.MenuOpen.Value then
                MouseHeld = false;
                DragTracerPosition = false;
                local IgnoreOtherInput = false;

                if SubMenu.Open and not MouseHoveringOver(SubMenu.Bounds) then
                    if CurrentColorPicker and IsMouseOverDrawing(CurrentColorPicker.Drawings['Square-Background']()) then IgnoreOtherInput = true; end
                    if not IgnoreOtherInput then SubMenu:Hide() end
                end

                if not IgnoreOtherInput then
                    for i, v in pairs(UIButtons) do
                        if SubMenu.Open and MouseHoveringOver(SubMenu.Bounds) and not v.FromSubMenu then continue end

                        local Values = {
                            v.Instance.Position.X;
                            v.Instance.Position.Y;
                            v.Instance.Position.X + v.Instance.Size.X;
                            v.Instance.Position.Y + v.Instance.Size.Y;
                        };
                        if MouseHoveringOver(Values) then
                            v.Option();
                            IgnoreOtherInput = true;
                            break -- prevent clicking 2 options
                        end
                    end
                    for i, v in pairs(Sliders) do
                        if IgnoreOtherInput then break end

                        local Values = {
                            v.Line.Position.X;
                            v.Line.Position.Y;
                            v.Line.Position.X + v.Line.Size.X;
                            v.Line.Position.Y + v.Line.Size.Y;
                        };
                        if not MouseHoveringOver(Values) then
                            v:ShowValue(false);
                        end
                    end
                end
            elseif input.UserInputType.Name == 'MouseButton2' and Options.MenuOpen.Value and not DragTracerPosition then
                local Values = {
                    TracerPosition.X - 10;
                    TracerPosition.Y - 10;
                    TracerPosition.X + 10;
                    TracerPosition.Y + 10;
                }
                if MouseHoveringOver(Values) then
                    DragTracerPosition = false;
                    TracerPosition = V2New(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y - 135);
                end
            elseif input.UserInputType.Name == 'Keyboard' then
                if Binding then
                    BindedKey = input.KeyCode;
                    Binding = false;
                elseif input.KeyCode == Options.MenuKey.Value or (input.KeyCode == Enum.KeyCode.Home and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)) then
                    Options.MenuOpen();
                elseif input.KeyCode == Options.ToggleKey.Value then
                    Options.Enabled();
                elseif input.KeyCode.Name == 'F1' and UserInputService:IsMouseButtonPressed(1) and shared.am_ic3 then -- hehe hiden spectate feature cuz why not
                    local HD, LPlayer, LCharacter = 0.95;

                    for i, Player in pairs(Players:GetPlayers()) do
                        local Character = GetCharacter(Player);

                        if Player ~= LocalPlayer and Player ~= Spectating and Character and Character:FindFirstChild'HumanoidRootPart' then
                            local Head = Character:FindFirstChild'Head';
                            local Humanoid = Character:FindFirstChildOfClass'Humanoid';
                            
                            if Head then
                                local Distance  = (Camera.CFrame.Position - Head.Position).Magnitude;
                                
                                if Distance > Options.MaxDistance.Value then continue; end

                                local Direction = -(Camera.CFrame.Position - Mouse.Hit.Position).unit;
                                local Relative  = Character.Head.Position - Camera.CFrame.Position;
                                local Unit      = Relative.unit;

                                local DP = Direction:Dot(Unit);

                                if DP > HD then
                                    HD = DP;
                                    LPlayer = Player;
                                    LCharacter = Character;
                                end
                            end
                        end
                    end
                    
                    if LPlayer and LPlayer ~= Spectating and LCharacter then
                        Camera.CameraSubject = LCharacter.Head;
                        Spectating = LPlayer;
                    else
                        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass'Humanoid' then
                            Camera.CameraSubject = LocalPlayer.Character:FindFirstChildOfClass'Humanoid';
                            Spectating = nil;
                        end
                    end
                end
            end
        end)

        local function CameraCon() -- unnamed esp v1 sucks
            workspace.CurrentCamera:GetPropertyChangedSignal'ViewportSize':Connect(function()
                TracerPosition = V2New(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y - 135);
            end);
        end

        CameraCon();

        local function ToggleMenu()
            if Options.MenuOpen.Value then
                GetTableData(shared.MenuDrawingData.Instances)(function(i, v)
                    if OldData[v] then
                        pcall(Set, v, 'Visible', true);
                    end
                end)
            else
                GetTableData(shared.MenuDrawingData.Instances)(function(i, v)
                    OldData[v] = v.Visible;
                    if v.Visible then
                        pcall(Set, v, 'Visible', false);
                    end
                end)
            end
        end

        local LastRayIgnoreUpdate, RayIgnoreList = 0, {}

        local function CheckRay(Instance, Distance, Position, Unit)
            local Pass = true;
            local Model = Instance;

            if Distance > 999 then return false; end

            if Instance.ClassName == 'Player' then
                Model = GetCharacter(Instance);
            end

            if not Model then
                Model = Instance.Parent;

                if Model.Parent == workspace then
                    Model = Instance;
                end
            end

            if not Model then return false end

            local _Ray = Ray.new(Position, Unit * Distance)

            if tick() - LastRayIgnoreUpdate > 3 then
                LastRayIgnoreUpdate = tick()

                table.clear(RayIgnoreList)

                table.insert(RayIgnoreList, LocalPlayer.Character)
                table.insert(RayIgnoreList, Camera)
                
                if Mouse.TargetFilter then table.insert(RayIgnoreList, Mouse.TargetFilter) end

                if #IgnoreList > 64 then
                    while #IgnoreList > 64 do
                        table.remove(IgnoreList, 1)
                    end
                end

                for i, v in pairs(IgnoreList) do table.insert(RayIgnoreList, v) end
            end

            local Hit = workspace:FindPartOnRayWithIgnoreList(_Ray, RayIgnoreList)

            if Hit and not Hit:IsDescendantOf(Model) then
                Pass = false;
                if Hit.Transparency >= .3 or not Hit.CanCollide and Hit.ClassName ~= Terrain then -- Detect invisible walls
                    table.insert(IgnoreList, Hit)
                    -- IgnoreList[#IgnoreList + 1] = Hit;
                end
            end

            return Pass;
        end

        local function CheckTeam(Player)
            if Player.Neutral and LocalPlayer.Neutral then return true; end
            return Player.TeamColor == LocalPlayer.TeamColor;
        end

        local CustomTeam = CustomTeams[game.PlaceId];

        if CustomTeam ~= nil then
            if CustomTeam.Initialize then ypcall(CustomTeam.Initialize) end

            CheckTeam = CustomTeam.CheckTeam;
        end

        local function CheckPlayer(Player, Character)
            if not Options.Enabled.Value then return false end

            local Pass = true;
            local Distance = 0;

            if Player ~= LocalPlayer and Character then
                if not Options.ShowTeam.Value and CheckTeam(Player) then
                    Pass = false;
                end

                local Head = Character:FindFirstChild'Head';

                if Pass and Character and Head then
                    Distance = (Camera.CFrame.Position - Head.Position).Magnitude;
                    if Options.VisCheck.Value then
                        Pass = CheckRay(Player, Distance, Camera.CFrame.Position, (Head.Position - Camera.CFrame.Position).unit);
                    end
                    if Distance > Options.MaxDistance.Value then
                        Pass = false;
                    end
                end
            else
                Pass = false;
            end

            return Pass, Distance;
        end

        local function CheckDistance(Instance)
            if not Options.Enabled.Value then return false end

            local Pass = true;
            local Distance = 0;

            if Instance ~= nil then
                Distance = (Camera.CFrame.Position - Instance.Position).Magnitude;
                if Options.VisCheck.Value then
                    Pass = CheckRay(Instance, Distance, Camera.CFrame.Position, (Instance.Position - Camera.CFrame.Position).unit);
                end
                if Distance > Options.MaxDistance.Value then
                    Pass = false;
                end
            else
                Pass = false;
            end

            return Pass, Distance;
        end

        local function UpdatePlayerData()
            if (tick() - LastRefresh) > (Options.RefreshRate.Value / 1000) then
                LastRefresh = tick();
                if CustomESP and Options.Enabled.Value then
                    local a, b = pcall(CustomESP);
                end
                for i, v in pairs(RenderList.Instances) do
                    if v.Instance ~= nil and v.Instance.Parent ~= nil and v.Instance:IsA'BasePart' then
                        local Data = shared.InstanceData[v.Instance:GetDebugId()] or { Instances = {}; DontDelete = true };

                        Data.Instance = v.Instance;

                        Data.Instances['OutlineTracer'] = Data.Instances['OutlineTracer'] or NewDrawing'Line'{
                            Transparency	= 0.75;
                            Thickness		= 5;
                            Color 			= Color3.new(0.1, 0.1, 0.1);
                        }
                        Data.Instances['Tracer'] = Data.Instances['Tracer'] or NewDrawing'Line'{
                            Transparency	= 1;
                            Thickness		= 2;
                        }
                        Data.Instances['NameTag'] = Data.Instances['NameTag'] or NewDrawing'Text'{
                            Size			= Options.TextSize.Value;
                            Center			= true;
                            Outline			= Options.TextOutline.Value;
                            Visible			= true;
                        };
                        Data.Instances['DistanceTag'] = Data.Instances['DistanceTag'] or NewDrawing'Text'{
                            Size			= Options.TextSize.Value - 1;
                            Center			= true;
                            Outline			= Options.TextOutline.Value;
                            Visible			= true;
                        };

                        local NameTag		= Data.Instances['NameTag'];
                        local DistanceTag	= Data.Instances['DistanceTag'];
                        local Tracer		= Data.Instances['Tracer'];
                        local OutlineTracer	= Data.Instances['OutlineTracer'];

                        local Pass, Distance = CheckDistance(v.Instance);

                        if Pass then
                            local ScreenPosition, Vis = WorldToViewport(v.Instance.Position);
                            local Color = v.Color;
                            local OPos = Camera.CFrame:pointToObjectSpace(v.Instance.Position);
                            
                            if ScreenPosition.Z < 0 then
                                local AT = math.atan2(OPos.Y, OPos.X) + math.pi;
                                OPos = CFrame.Angles(0, 0, AT):vectorToWorldSpace((CFrame.Angles(0, math.rad(89.9), 0):vectorToWorldSpace(V3New(0, 0, -1))));
                            end
                            
                            local Position = WorldToViewport(Camera.CFrame:pointToWorldSpace(OPos));

                            if Options.ShowTracers.Value then
                                Tracer.Transparency = math.clamp(Distance / 200, 0.45, 0.8);
                                Tracer.Visible	= true;
                                Tracer.From		= TracerPosition;
                                Tracer.To		= V2New(Position.X, Position.Y);
                                Tracer.Color	= Color;
                                OutlineTracer.Visible = true;
                                OutlineTracer.Transparency = Tracer.Transparency - 0.1;
                                OutlineTracer.From = Tracer.From;
                                OutlineTracer.To = Tracer.To;
                                OutlineTracer.Color	= Color3.new(0.1, 0.1, 0.1);
                            else
                                Tracer.Visible = false;
                                OutlineTracer.Visible = false;
                            end

                            if ScreenPosition.Z > 0 then
                                local ScreenPositionUpper = ScreenPosition;
                                
                                if Options.ShowName.Value then
                                    LocalPlayer.NameDisplayDistance = 0;
                                    NameTag.Visible		= true;
                                    NameTag.Text		= v.Text;
                                    NameTag.Size		= Options.TextSize.Value;
                                    NameTag.Outline		= Options.TextOutline.Value;
                                    NameTag.Position	= V2New(ScreenPositionUpper.X, ScreenPositionUpper.Y);
                                    NameTag.Color		= Color;
                                    if Drawing.Fonts and shared.am_ic3 then -- CURRENTLY SYNAPSE ONLY :MEGAHOLY:
                                        NameTag.Font	= Drawing.Fonts.Monospace;
                                    end
                                else
                                    LocalPlayer.NameDisplayDistance = 100;
                                    NameTag.Visible = false;
                                end
                                if Options.ShowDistance.Value or Options.ShowHealth.Value then
                                    DistanceTag.Visible		= true;
                                    DistanceTag.Size		= Options.TextSize.Value - 1;
                                    DistanceTag.Outline		= Options.TextOutline.Value;
                                    DistanceTag.Color		= Color3.new(1, 1, 1);
                                    if Drawing.Fonts and shared.am_ic3 then -- CURRENTLY SYNAPSE ONLY :MEGAHOLY:
                                        NameTag.Font	= Drawing.Fonts.Monospace;
                                    end

                                    local Str = '';

                                    if Options.ShowDistance.Value then
                                        Str = Str .. Format('[%d] ', Distance);
                                    end

                                    DistanceTag.Text = Str;
                                    DistanceTag.Position = V2New(ScreenPositionUpper.X, ScreenPositionUpper.Y) + V2New(0, NameTag.TextBounds.Y);
                                else
                                    DistanceTag.Visible = false;
                                end
                            else
                                NameTag.Visible			= false;
                                DistanceTag.Visible		= false;
                            end
                        else
                            NameTag.Visible			= false;
                            DistanceTag.Visible		= false;
                            Tracer.Visible			= false;
                            OutlineTracer.Visible	= false;
                        end

                        Data.Instances['NameTag'] 		= NameTag;
                        Data.Instances['DistanceTag']	= DistanceTag;
                        Data.Instances['Tracer']		= Tracer;
                        Data.Instances['OutlineTracer']	= OutlineTracer;

                        shared.InstanceData[v.Instance:GetDebugId()] = Data;
                    end
                end
                for i, v in pairs(Players:GetPlayers()) do
                    local Data = shared.InstanceData[v.Name] or { Instances = {}; };

                    Data.Instances['Box'] = Data.Instances['Box'] or LineBox:Create{Thickness = 4};
                    Data.Instances['OutlineTracer'] = Data.Instances['OutlineTracer'] or NewDrawing'Line'{
                        Transparency	= 1;
                        Thickness		= 3;
                        Color			= Color3.new(0.1, 0.1, 0.1);
                    }
                    Data.Instances['Tracer'] = Data.Instances['Tracer'] or NewDrawing'Line'{
                        Transparency	= 1;
                        Thickness		= 1;
                    }
                    Data.Instances['HeadDot'] = Data.Instances['HeadDot'] or NewDrawing'Circle'{
                        Filled			= true;
                        NumSides		= 30;
                    }
                    Data.Instances['NameTag'] = Data.Instances['NameTag'] or NewDrawing'Text'{
                        Size			= Options.TextSize.Value;
                        Center			= true;
                        Outline			= Options.TextOutline.Value;
                        OutlineOpacity	= 1;
                        Visible			= true;
                    };
                    Data.Instances['DistanceHealthTag'] = Data.Instances['DistanceHealthTag'] or NewDrawing'Text'{
                        Size			= Options.TextSize.Value - 1;
                        Center			= true;
                        Outline			= Options.TextOutline.Value;
                        OutlineOpacity	= 1;
                        Visible			= true;
                    };

                    local NameTag		= Data.Instances['NameTag'];
                    local DistanceTag	= Data.Instances['DistanceHealthTag'];
                    local Tracer		= Data.Instances['Tracer'];
                    local OutlineTracer	= Data.Instances['OutlineTracer'];
                    local HeadDot		= Data.Instances['HeadDot'];
                    local Box			= Data.Instances['Box'];

                    local Character = GetCharacter(v);
                    local Pass, Distance = CheckPlayer(v, Character);

                    if Pass and Character then
                        local Humanoid = Character:FindFirstChildOfClass'Humanoid';
                        local Head = Character:FindFirstChild'Head';
                        local HumanoidRootPart = Character:FindFirstChild(CustomRootPartName or 'HumanoidRootPart')

                        local Dead = (Humanoid and Humanoid:GetState().Name == 'Dead')
                        
                        if type(GetAliveState) == 'function' then
                            Dead = (not GetAliveState(v, Character))
                        end

                        if Character ~= nil and Head and HumanoidRootPart and not Dead then
                            local ScreenPosition, Vis = WorldToViewport(Head.Position);
                            local Color = Rainbow and Color3.fromHSV(tick() * 128 % 255/255, 1, 1) or (CheckTeam(v) and TeamColor or EnemyColor); Color = Options.ShowTeamColor.Value and v.TeamColor.Color or Color;
                            local OPos = Camera.CFrame:pointToObjectSpace(Head.Position);
                            
                            if ScreenPosition.Z < 0 then
                                local AT = math.atan2(OPos.Y, OPos.X) + math.pi;
                                OPos = CFrame.Angles(0, 0, AT):vectorToWorldSpace((CFrame.Angles(0, math.rad(89.9), 0):vectorToWorldSpace(V3New(0, 0, -1))));
                            end
                            
                            local Position = WorldToViewport(Camera.CFrame:pointToWorldSpace(OPos));

                            if Options.ShowTracers.Value then
                                if TracerPosition.X >= Camera.ViewportSize.X or TracerPosition.Y >= Camera.ViewportSize.Y or TracerPosition.X < 0 or TracerPosition.Y < 0 then
                                    TracerPosition = V2New(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y - 135);
                                end

                                Tracer.Visible	= true;
                                Tracer.Transparency = math.clamp(1 - (Distance / 200), 0.25, 0.75);
                                Tracer.From		= TracerPosition;
                                Tracer.To		= V2New(Position.X, Position.Y);
                                Tracer.Color	= Color;
                                OutlineTracer.From = Tracer.From;
                                OutlineTracer.To = Tracer.To;
                                OutlineTracer.Transparency = Tracer.Transparency - 0.15;
                                OutlineTracer.Visible = true;
                            else
                                Tracer.Visible = false;
                                OutlineTracer.Visible = false;
                            end
                            
                            if ScreenPosition.Z > 0 then
                                local ScreenPositionUpper	= WorldToViewport((HumanoidRootPart:GetRenderCFrame() * CFrame.new(0, Head.Size.Y + HumanoidRootPart.Size.Y + (Options.YOffset.Value / 25), 0)).Position);
                                local Scale					= Head.Size.Y / 2;

                                if Options.ShowName.Value then
                                    NameTag.Visible		= true;
                                    NameTag.Text		= v.Name .. (CustomPlayerTag and CustomPlayerTag(v) or '');
                                    NameTag.Size		= Options.TextSize.Value;
                                    NameTag.Outline		= Options.TextOutline.Value;
                                    NameTag.Position	= V2New(ScreenPositionUpper.X, ScreenPositionUpper.Y) - V2New(0, NameTag.TextBounds.Y);
                                    NameTag.Color		= Color;
                                    NameTag.Color		= Color;
                                    NameTag.OutlineColor= Color3.new(0.05, 0.05, 0.05);
                                    NameTag.Transparency= 0.85;
                                    if Drawing.Fonts and shared.am_ic3 then -- CURRENTLY SYNAPSE ONLY :MEGAHOLY:
                                        NameTag.Font	= Drawing.Fonts.Monospace;
                                    end
                                else
                                    NameTag.Visible = false;
                                end
                                if Options.ShowDistance.Value or Options.ShowHealth.Value then
                                    DistanceTag.Visible		= true;
                                    DistanceTag.Size		= Options.TextSize.Value - 1;
                                    DistanceTag.Outline		= Options.TextOutline.Value;
                                    DistanceTag.Color		= Color3.new(1, 1, 1);
                                    DistanceTag.Transparency= 0.85;
                                    if Drawing.Fonts and shared.am_ic3 then -- CURRENTLY SYNAPSE ONLY :MEGAHOLY:
                                        NameTag.Font	= Drawing.Fonts.Monospace;
                                    end

                                    local Str = '';

                                    if Options.ShowDistance.Value then
                                        Str = Str .. Format('[%d] ', Distance);
                                    end
                                    if Options.ShowHealth.Value then								
                                        if typeof(Humanoid) == 'Instance' then
                                            Str = Str .. Format('[%d/%d] [%s%%]', Humanoid.Health, Humanoid.MaxHealth, math.floor(Humanoid.Health / Humanoid.MaxHealth * 100));
                                        elseif type(GetHealth) == 'function' then
                                            local health, maxHealth = GetHealth(v)
                                            
                                            if type(health) == 'number' and type(maxHealth) == 'number' then
                                                Str = Str .. Format('[%d/%d] [%s%%]', health, maxHealth, math.floor(health / maxHealth * 100))
                                            end
                                        end
                                    end

                                    DistanceTag.Text = Str;
                                    DistanceTag.OutlineColor = Color3.new(0.05, 0.05, 0.05);
                                    DistanceTag.Position = (NameTag.Visible and NameTag.Position + V2New(0, NameTag.TextBounds.Y) or V2New(ScreenPositionUpper.X, ScreenPositionUpper.Y));
                                else
                                    DistanceTag.Visible = false;
                                end
                                if Options.ShowDot.Value and Vis then
                                    local Top			= WorldToViewport((Head.CFrame * CFrame.new(0, Scale, 0)).Position);
                                    local Bottom		= WorldToViewport((Head.CFrame * CFrame.new(0, -Scale, 0)).Position);
                                    local Radius		= math.abs((Top - Bottom).Y);

                                    HeadDot.Visible		= true;
                                    HeadDot.Color		= Color;
                                    HeadDot.Position	= V2New(ScreenPosition.X, ScreenPosition.Y);
                                    HeadDot.Radius		= Radius;
                                else
                                    HeadDot.Visible = false;
                                end
                                if Options.ShowBoxes.Value and Vis and HumanoidRootPart then
                                    local Body = {
                                        Head;
                                        Character:FindFirstChild'Left Leg' or Character:FindFirstChild'LeftLowerLeg';
                                        Character:FindFirstChild'Right Leg' or Character:FindFirstChild'RightLowerLeg';
                                        Character:FindFirstChild'Left Arm' or Character:FindFirstChild'LeftLowerArm';
                                        Character:FindFirstChild'Right Arm' or Character:FindFirstChild'RightLowerArm';
                                    }
                                    Box:Update(HumanoidRootPart.CFrame, V3New(2, 3, 1) * (Scale * 2), Color, nil, shared.am_ic3 and Body);
                                else
                                    Box:SetVisible(false);
                                end
                            else
                                NameTag.Visible			= false;
                                DistanceTag.Visible		= false;
                                HeadDot.Visible			= false;
                                
                                Box:SetVisible(false);
                            end
                        else
                            NameTag.Visible			= false;
                            DistanceTag.Visible		= false;
                            HeadDot.Visible			= false;
                            Tracer.Visible			= false;
                            OutlineTracer.Visible 	= false;
                            
                            Box:SetVisible(false);
                        end
                    else
                        NameTag.Visible			= false;
                        DistanceTag.Visible		= false;
                        HeadDot.Visible			= false;
                        Tracer.Visible			= false;
                        OutlineTracer.Visible 	= false;

                        Box:SetVisible(false);
                    end

                    shared.InstanceData[v.Name] = Data;
                end
            end
        end

        local LastInvalidCheck = 0;

        local function Update()
            if tick() - LastInvalidCheck > 0.3 then
                LastInvalidCheck = tick();

                if Camera.Parent ~= workspace then
                    Camera = workspace.CurrentCamera;
                    CameraCon();
                    WTVP = Camera.WorldToViewportPoint;
                end

                for i, v in pairs(shared.InstanceData) do
                    if not Players:FindFirstChild(tostring(i)) then
                        if not shared.InstanceData[i].DontDelete then
                            GetTableData(v.Instances)(function(i, obj)
                                obj.Visible = false;
                                obj:Remove();
                                v.Instances[i] = nil;
                            end)
                            shared.InstanceData[i] = nil;
                        else
                            if shared.InstanceData[i].Instance == nil or shared.InstanceData[i].Instance.Parent == nil then
                                GetTableData(v.Instances)(function(i, obj)
                                    obj.Visible = false;
                                    obj:Remove();
                                    v.Instances[i] = nil;
                                end)
                                shared.InstanceData[i] = nil;
                            end
                        end
                    end
                end
            end

            local CX = Menu:GetInstance'CrosshairX';
            local CY = Menu:GetInstance'CrosshairY';
            
            if Options.Crosshair.Value then
                CX.Visible = true;
                CY.Visible = true;

                CX.To = V2New((Camera.ViewportSize.X / 2) - 8, (Camera.ViewportSize.Y / 2));
                CX.From = V2New((Camera.ViewportSize.X / 2) + 8, (Camera.ViewportSize.Y / 2));
                CY.To = V2New((Camera.ViewportSize.X / 2), (Camera.ViewportSize.Y / 2) - 8);
                CY.From = V2New((Camera.ViewportSize.X / 2), (Camera.ViewportSize.Y / 2) + 8);
            else
                CX.Visible = false;
                CY.Visible = false;
            end

            if Options.MenuOpen.Value and MenuLoaded then
                local MLocation = GetMouseLocation();
                shared.MenuDrawingData.Instances.Main.Color = Color3.fromHSV(tick() * 24 % 255/255, 1, 1);
                local MainInstance = Menu:GetInstance'Main';
                
                local Values = {
                    MainInstance.Position.X;
                    MainInstance.Position.Y;
                    MainInstance.Position.X + MainInstance.Size.X;
                    MainInstance.Position.Y + MainInstance.Size.Y;
                };
                
                if MainInstance and (MouseHoveringOver(Values) or (SubMenu.Open and MouseHoveringOver(SubMenu.Bounds))) then
                    Debounce.CursorVis = true;
                    
                    Menu:UpdateMenuInstance'Cursor1'{
                        Visible	= true;
                        From	= V2New(MLocation.x, MLocation.y);
                        To		= V2New(MLocation.x + 5, MLocation.y + 6);
                    }
                    Menu:UpdateMenuInstance'Cursor2'{
                        Visible	= true;
                        From	= V2New(MLocation.x, MLocation.y);
                        To		= V2New(MLocation.x, MLocation.y + 8);
                    }
                    Menu:UpdateMenuInstance'Cursor3'{
                        Visible	= true;
                        From	= V2New(MLocation.x, MLocation.y + 6);
                        To		= V2New(MLocation.x + 5, MLocation.y + 5);
                    }
                else
                    if Debounce.CursorVis then
                        Debounce.CursorVis = false;
                        
                        Menu:UpdateMenuInstance'Cursor1'{Visible = false};
                        Menu:UpdateMenuInstance'Cursor2'{Visible = false};
                        Menu:UpdateMenuInstance'Cursor3'{Visible = false};
                    end
                end
                if MouseHeld then
                    local MousePos = GetMouseLocation();

                    if Dragging then
                        DraggingWhat.Slider.Position = V2New(math.clamp(MLocation.X - DraggingWhat.Slider.Size.X / 2, DraggingWhat.Line.Position.X, DraggingWhat.Line.Position.X + DraggingWhat.Line.Size.X - DraggingWhat.Slider.Size.X), DraggingWhat.Slider.Position.Y);
                        local Percent	= (DraggingWhat.Slider.Position.X - DraggingWhat.Line.Position.X) / ((DraggingWhat.Line.Position.X + DraggingWhat.Line.Size.X - DraggingWhat.Line.Position.X) - DraggingWhat.Slider.Size.X);
                        local Value		= CalculateValue(DraggingWhat.Min, DraggingWhat.Max, Percent);
                        DraggingWhat.Option(Value);
                    elseif DraggingUI then
                        Debounce.UIDrag = true;
                        local Main = Menu:GetInstance'Main';
                        Main.Position = MousePos + DragOffset;
                    elseif DragTracerPosition then
                        TracerPosition = MousePos;
                    end
                else
                    Dragging = false;
                    DragTracerPosition = false;
                    if DraggingUI and Debounce.UIDrag then
                        Debounce.UIDrag = false;
                        DraggingUI = false;
                        CreateMenu(Menu:GetInstance'Main'.Position);
                    end
                end
                if not Debounce.Menu then
                    Debounce.Menu = true;
                    ToggleMenu();
                end
            elseif Debounce.Menu and not Options.MenuOpen.Value then
                Debounce.Menu = false;
                ToggleMenu();
            end
        end

        RunService:UnbindFromRenderStep(GetDataName);
        RunService:UnbindFromRenderStep(UpdateName);

        RunService:BindToRenderStep(GetDataName, 300, UpdatePlayerData);
        RunService:BindToRenderStep(UpdateName, 199, Update);
   end,
})

local FunTab = Window:CreateTab("Fun", "laugh") -- Title, Image

local FunSection = FunTab:CreateSection("Fun")

local flipButton = FunTab:CreateButton({
   Name = "FrontFlip",
   Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/SHRTRYScriptMANhere/stolenahhfrotflip/refs/heads/main/Flip",true))()
   end,
})

local Button = EditorTab:CreateButton({
   Name = "Noclip",
   Callback = function()
        local UserInputService = game:GetService("UserInputService")
        local RunService = game:GetService("RunService")
        local player = game.Players.LocalPlayer
        local starterGui = game:GetService("StarterGui")

        local isActive = false
        local isScriptDisabled = false
        local canToggle = true

        starterGui:SetCore("SendNotification", {
            Title = "Noclip, made by Umvtt",
            Text = "Controls:\n- Ctrl + K: Toggle\n- Alt + K: Fully Stop",
            Duration = 5
        })

        local function getCharacter()
            return player.Character or player.CharacterAdded:Wait()
        end

        local function showNotification(message)
            starterGui:SetCore("SendNotification", {
                Title = "Script Status",
                Text = "Noclip " .. message,
                Duration = 2
            })
        end

        local function toggleNoClip()
            if not canToggle or isScriptDisabled then return end
            canToggle = false

            isActive = not isActive
            showNotification(isActive and "Enabled!" or "Disabled!")

            local character = getCharacter()
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

            if isActive then
                -- Ki·ªÉm tra n·∫øu nh√¢n v·∫≠t ch·∫øt, d·ª´ng script
                local humanoid = character:WaitForChild("Humanoid")
                humanoid.Died:Connect(function()
                    isActive = false
                    showNotification("Disabled due to death!")
                end)

                RunService.Stepped:Connect(function()
                    if isActive and character and humanoidRootPart then
                        for _, part in pairs(character:GetChildren()) do
                            if part:IsA("BasePart") then
                                part.CanCollide = false
                            end
                        end
                    end
                end)
            end

            task.wait(0.5)
            canToggle = true
        end

        local function disableScript()
            if isScriptDisabled then return end
            isScriptDisabled = true
            isActive = false

            local character = getCharacter()
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end

            starterGui:SetCore("SendNotification", {
                Title = "Script Stopped",
                Text = "Noclip fully closed successfully!",
                Duration = 2
            })
        end

        UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end

            if input.KeyCode == Enum.KeyCode.K and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                toggleNoClip()
            elseif input.KeyCode == Enum.KeyCode.K and UserInputService:IsKeyDown(Enum.KeyCode.LeftAlt) then
                disableScript()
            end
        end)
   end,
})

local Button = FunTab:CreateButton({
   Name = "Jerk Off",
   Callback = function()
        loadstring(game:HttpGet("https://pastefy.app/wa3v2Vgm/raw"))("Spider Script")
   end,
})

local ScriptsTab = Window:CreateTab("Scripts", "code") -- Title, Image

local ScriptsSection = ScriptsTab:CreateSection("Scripts")

local yieldButton = ScriptsTab:CreateButton({
   Name = "Infinite Yield",
   Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
   end,
})

local forsakenButton = ScriptsTab:CreateButton({
   Name = "Forsaken Script",
   Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/BobJunior1/ForsakenBoi/refs/heads/main/B0bbyHub"))() 
   end,
})

local BkeyLabel = ScriptsTab:CreateLabel("Forsaken Script Key: IFarted", nil, Color3.fromRGB(0, 255, 0), false) -- Title, Icon, Color, IgnoreTheme
local dangerLabel = ScriptsTab:CreateLabel("THESE SCRIPTS ARE NOT MINE", nil, Color3.fromRGB(255, 0, 0), false) -- Title, Icon, Color, IgnoreTheme

local SettingsTab = Window:CreateTab("Settings", "settings") -- Title, Image

local SettingsSection = SettingsTab:CreateSection("Settings")

local SafeModeToggle = SettingsTab:CreateToggle({
   Name = "Safe Mode",
   CurrentValue = true,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
   -- The function that takes place when the toggle is pressed
   -- The variable (Value) is a boolean on whether the toggle is true or false
   end,
})

local Button = SettingsTab:CreateButton({
   Name = "Shut Down",
   Callback = function()
        Rayfield:Destroy()
   end,
})
